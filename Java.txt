A profissão de programador Java Web é enorme e assim como você
eu fiquei sem saber por onde seguir! E com esse e-book vou te
ensinar o caminho correto para ser um programador.
Curso mais
completo do Brasil
Passo a passo
para ser programador
Java Web
Livro gratuito de JAVA WEB
1 – História do Java
Criada em 1995 pela Sun Microsystems e comprada pela Oracle em 2008 pelo valor de $ 7,4 biliões de dólares.
Grande responsável pela disseminação da programação orientada a objetos ou chamada também de POO ou OO.
A maioria das linguagens criadas atualmente são muito parecidas com Java e adotam/copiam sua lista enorme de
conceitos e soluções, como:
Groovy, Scala, JPython , Python, Jruby, TypeScript e o Ruby e muitas outras.
Compilado e rodada em cima da JVM máquina virtual Java, essa linguagem tem o poder de rodar em qualquer
lugar.
Relógio, celular, computadores, notebook, carros, torradeiras elétricas, em tudo mesmo desde que o equipamento
aceite a instalação.
O Java tem o grande beneficio de que um sistema escrito em versões anteriores rode sem nenhum problema em
versões mais novas e isso faz com que empresas multinacionais, banco, sistemas do governo, sistemas militares e
grandes corporações se sintam seguras em criar os sistemas usando Java.
E também pela sua enorme segurança nas aplicações com o beneficio de ser compilada gerando bytecode, assim
não é possível um invasor alterar o seu código e mudar o processamento real do sistema o que o torna a escolha
perfeita para empresas de software.
 OBS: Precisamos deixar bem claro que JavaScript não é Java, o Java é usado para fazer todo o processamento de
dados do lado do back-end nos servidores web.
O JavaScript é usado no front-end para mostrar os dados na tela e para deixar as telas do sistema interativas com
a pessoa, nos últimos anos também vem sendo possível rodar o JavaScript nos servidores usando por exemplo o
NodeJS (Veja AQUI).
Basicamente em um sistema web completo em Java nós usamos 86% de Java para todo o processamento e 14% de
JavaScript para criação das telas junto com vários frameworks para facilitar o desenvolvimento.
O front-end são as telas do sistema tudo que o usuário vê na tela do computador, sempre é constituído de Html +
Css + JavaScript.
O back-end é toda a parte de estrutura onde realmente acontece todo o processamento de dados e sua
manipulação junto com o banco de dados e sql e código Java, PHP, NodeJS ou alguma outra linguagem Back-End.
Exemplo de um front-end é qualquer tela de um sistema de computador ou celular, alguma tela qualquer.
Abaixo tem a tela de impressão de certificado da minha EAD feito com Bootstrap e Thymeleaf.
Mais um exemplo de front-end a tela na área de estudos da minha EAD.
Criado com Bootstrap, Thymeleaf e jQuery.
Toda a parte de front-end no final quando é interpretado pelo navegador se torna Html + CSS + JavaScript.
Agora na parte de back-end é onde o bicho pega, é onde está 87% do código funcional, é onde está toda a regra
de negócio, é o que fornece os dados para o front-end mostrar, o back-end pode existir sozinho e efetuar
milhares de recursos mas é preciso de uma entrada de dados, esses dados têm que vir de algum lugar e de onde
vêm? De algum front-end, tela de computador, aplicativos, algum sistema web, alguma tela dá esses dados como
entrada, outro de uma forma mais avançada pode haver um equipamento como é o caso da previsão do tempo a
entrada de dados vem de um hardware, mas no final é preciso de front-end para mostrar os dados para nós.
Bem, o back-end não tem como ser mostrado em uma única imagem, mas aqui vai um exemplo do projeto da
Plataforma EAD Jdev Treinamento.
Criado 100% em Java, levei quase 2 anos pra deixar ela no ponto que está com muitos recursos, você pode testar
toda a plataforma realizando o cadastro gratuito clicando AQUI.
O Java é atualmente uma das linguagens mais utilizadas em todo o mundo, em ainda em crescimento nas
empresas, através de novas adoções. Uma coisa que se deve mencionar é que hoje o Java não é apenas uma
linguagem, mas sim uma plataforma de desenvolvimento.
Nos últimos anos o Java vem sendo usado por todo o mundo dentre as características podemos citar as seguintes:
• Aprenda Java e programe em qualquer plataforma e SO: Uma das grandes vantagens do Java é que ele além
de ser uma linguagem é uma plataforma de desenvolvimento. Com ele é possível desenvolver aplicações para
desktop, celular, cartão, web, televisão digital, etc.
• Comunidades: Os grupos de usuários Java são muito fortes em todo o mundo e graças a eles é possível obter
material para estudos de maneira fácil, participar de encontros regionais, palestras e até minicursos. Neles
também é possível trocar experiência com pessoas que já atuam na área a mais tempo e o mais importante
que é obter soluções para qualquer problema.
• Grande número de frameworks: Graças ao investimento das comunidades e também de algumas empresas,
existem hoje uma variedade de frameworks que visam facilitar o trabalho do desenvolvedor.
• O Java não roda somente Java: A máquina virtual Java atualmente roda cerca de 350 linguagens com pontos
interessantes, por exemplo, o Groovy linguagem dinâmica, Scala que é específica para concorrência dentre
outras linguagens como JPython , Python, Jruby e o Ruby.
• Desenvolva em qualquer sistema operacional para qualquer sistema operacional: Quando se compila um
arquivo em Java ele gera um bytecode que é interpretado numa JVM. Bastando que o seu sistema operacional
tenha uma JVM, será possível executar o Java nos sistemas operacionais Windows, GNU/Linux e Mac. Suas
principais IDES, podemos citar o Eclipse e o Netbeans, rodam em Java, ou seja, se pode programar em
qualquer sistema operacional.
2 - Presente no desenvolvimento :
• App Mobile mais conhecido é o Android.
• Sistemas Web e Desktop
• Big Data
• Machine Learning
• IoT
• Sistema Embarcados em equipamentos.
• Inteligência artificial.
3 - O Java é dividido em algumas plataformas:
• Java SE conhecimento como o Java Desktop e roda nos servidores também.
• Java EE conhecido como Java Web ou EE que o e mais usado no mundo inteiro em sistema web complexos em
grandes empresas.
• Java Embedded para rodas em dispositivos limitados como sensores.
• Oracle Java SE Embedded para rodas em dispositivos baseados em rede.
• Java Card usado para dispositivos de Smart Card
• Java TV para criar aplicações para rodas em televisões digitais.
O que garante a qualidade dos sistemas criados com a linguagem Java é o poder da orientação a objetos, assim a
manutenção se torna fácil, legível e eficaz com a grande reutilização de código dentro do projetos.
4 - Alguns lugares famosos que usam Java.
NetFlix
PagSeguro
Mercado Livre
IFood
Banco Itaú
Hsbc
Santander
Bradesco
Receita Federal
Eclipse
NetBeans
Unimed
Banco Original
Banco Inter
Banco do Brasil
Banco Caixa Econômica Federal
Sicred
Sicoob
Claro
Vivo
Tim
Seguradoras
Spotify
Transportadoras
Farmácias
Mercados
Sistemas de Geolocalização
Sistemas administrativos, financeiros, analíticos e muito mais.
Etc... Etc..
Até a sua padaria da esquina usa Java.
5 – Extrema falta de programadores.
Com o passar o tempo e a criação de milhares de projetos e o avanço da tecnologia a demanda por pessoa que
saibam programar e que saibam Java aumentou dezenas de vezes.
Te faço um desafio, vá para o Google e pesquise pela frase “Vaga para programador Java.”
Você encontrará milhares de vagas em todas as cidades e estados do Brasil, e isso não é brincadeira, a demanda é
realmente enorme.
Muitos reclamam que é difícil se tornar um programador e na verdade quem não consegue é porque estuda da
forma errada, começam atropelando conteúdo, não seguem a sequência de aprendizado e ficam perdidos, pessoas
assim ficam fora do mercado e fica reclamando por aí.
6 – Java nunca morrerá – repita comido… NUNCA
Essa é uma frase que venho escutando a mais de 10 anos e sabe o que aconteceu nesses 10 anos, o Java evoluiu
absurdamente.
A quantidade de sistemas criados e vagas para trabalhar com Java multiplicaram 10 vezes.
Quem sabe daqui uns 30 anos, a verdade é, você quer ser programador e entrar no mercado com muitas
oportunidades e bom salários o Java é a melhor escolha.
Primeiro, Java possuí vaga em qualquer cidade do Brasil, dúvida… pesquisa no Google e comprove.
A quantidade de sistemas que existem no mercado de trabalho garante emprego para você nos próximos 30 anos.
É robusto e é seguro, quem sabe Java está com o sucesso nas mãos.
E sendo um programador você também tem a oportunidade de criar seu próprio sistema, adquirir clientes e faturar
muito alto sendo empreendedor e programador.
O Java será ou não pago?
A mudança de licenciamento do Java ocorreu em meados de 2018, causando muita polêmica entre os profissionais
de TI. Tais alterações têm uma explicação simples: há alguns anos, a Oracle comprou a Sun, empresa que, até
então, era detentora dos direitos do Java, e continuou publicando o programa gratuitamente.
No entanto, para que fossem feitas atualizações recorrentes do produto e fosse oferecido um suporte maior aos
usuários, a empresa resolveu fazer essa alteração no licenciamento. Assim, a Oracle tem implantado melhorias a
cada seis meses, lançando novas funcionalidades. O primeiro desses releases foi publicado em abril de 2019 e o
segundo tem previsão para outubro do mesmo ano.
Essa prática deve seguir sendo realizada até o final de 2020. A maior polêmica em relação às novas regras do Java
é o boato de que todas as versões do software seriam pagas.
Essa conversa começou a rodar os fóruns de TI da internet quando a Oracle comprou a Sun.
Como falado, depois que essa compra foi efetivada, o software seguiu sendo distribuído gratuitamente por um
tempo. No entanto, logo percebeu-se que ele demandava custos, e esses valores precisavam ser repassados aos
usuários para que não houvesse prejuízo. Dessa forma, o objetivo da cobrança é fazer com que mais atualizações
sejam realizadas no produto, bem como prestar um suporte mais eficiente para os usuários.
No entanto, não há motivo para pânico! A versão free do Java continuará existindo, porém, com recursos mais
limitados. As versões chamadas de LTS (Long Term Support), serão pagas, assim como as versões superiores a 11.
Mas ninguém é obrigado a adquiri-la, embora ela seja bastante vantajosa, como falaremos mais adiante.
Então para você aprender a programar e ter o Java em sua máquina você nunca pagará R$ 1 reais por isso.
E também todas as ferramentas para você aprender a programar também são totalmente gratuitas.
Maiores benefícios de estudar o meu curso on-line
Treinamento totalmente eficaz que te ensina totalmente do zero a programar em Java até os conhecimentos
necessários para você entrar no mercado de trabalho.
Como aumentar seu salário de programador? Ao mesmo tempo que a resposta é superfácil “Aprendendo mais,
lógico”, mas, como? Sabendo exatamente o que estudar e seguindo a sequência correta.
Você deve dominar os melhores e mais usados frameworks Java do mercado, como o melhor e mais famoso Spring
Framework e seu módulo Spring Boot.
A maioria dos treinamento te ensinam por pedaços, ecossistemas separados, mas como sair o júnior e juntar todas
as partes até o nível sênior, esse é meu objetivo com você.
De um simples estagiários á programador full-stack em java de verdade e sem mimi.
É muito comum ficar perdido no começo porque em cada lugar você encontra respostas diferentes para a mesma
pergunta, qual o caminho correto de estudo para aprender Java e entrar no mercado de trabalho? Eu vou te revelar
o caminho que eu fiz e que ficou comprovado que é eficaz e já está aprovado por mais de 60 mil alunos.
Tenha mentores e acompanhamentos nos estudos de Java.
Seja um programador disputado pelas empresas.
No mínimo você deve saber dominar muito bem o POO e saber fazer um CRUD com banco de dados real.
Domine as principais arquiteturas em Java EE, MVC, DAO, RESTfull, API, Controllers, Services, Modelos e etcs.
Domine front-end, back-end, e banco de dados em SQL em um único projeto.
Domine as técnicas de performance em Java e se destaque no mercado de software em Java.
Tenha em mente o passo a passo a ser seguido para ser um programado em Java de sucesso.
Problemas que você tem hoje e te impedem de ter sucesso.
Motivos por você ganhar pouco como programador:
Não sabe fazer mais que um crud, não sabe criar um relatório, não sabe criar um gráfico, não sabe fazer uma API,
não desenvolve habilidade de autodidata e pesquisa, não traz soluções novas para a equipe ou projeto, não
domina SQL e banco de dados fortemente, não desenvolve habilidade de correção de erros e debug.
Fica travado na programação e não consegue desenvolver a lógica pra escrever o código.
Não consegue entender e como ligar os dados e o fluxo dos frameworks e projetos de software, mesmo que seja
um simples CRUD.
Está tendo a impressão que está ficando de fora do mercado por não saber o caminho correto de estudo que o
mercado precisa que você tenha.
Como resolver todos esses problemas?
Você precisa urgente desenvolver disciplina e seguir um método de estudo correto e organizado.
É obrigatório que você aprenda a criar no mínimo um CRUD com as arquiteturas mais usadas com Java e se
frameworks de sucesso no mercado.
Você não pode de forma alguma tentar aprender várias linguagens ao mesmo tempo, isso só irá de atrasar cada
vez mais.
Você precisa aprender a olhar os requisitos das vagas de emprego no mercado de trabalho e focar seu estudo nos
assuntos pedidos.
Você precisa HOJE MESMO, aprender a resolver os problemas mais comuns que ocorrem no dia a dia de um
programador.
Perder o medo de alterar o código e testar, e também encontrar as respostas na documentação e ajuda da IDE de
desenvolvimento.
Se você é iniciante sua única oportunidade é estar comigo e aprender com quem está a 14 anos no mercado como
desenvolver/programador Java de sucesso.
Programador EXPERT é assim…
Estuda com livros, cursos on-line, tutoriais, Google, Youtube, participa de comunidades, grupos e todo dia mesmo
aprende algo novo.
Nunca mais fica desempregado.
A empresa corre atrás de programadores que possuem os requisitos citados até esse ponto.
Não fica patinando sem rumo na profissão.
E para isso, para ser esse programador de sucesso você precisa de método presente no meu curso, FORMAÇÃO
JAVA WEB FULL-STACK.
CLIQUE NO BOTÃO VERDE ABAIXO PARA COMEÇAR IMEDIATAMENTE.
- Mais de 50 módulos.
- 22 certificados válidos.
- 1100 videoaulas passo a passo.
- Acesso vitalicio.
- Garantia de 30 dias.
- Suporte total da equipe para suas dúvidas.
- Atualizações sem custo.
Maior Formação em Java do Brasil com 60 mil alunos – CLIQUE AQUI
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 3
Alex Fernando Egidio
Autor, criador e fundador do JDev Treinamento
TI. Atua no mercado como desenvolvedor e
engenheiro de sistemas em Java é apaixonado por
desenvolvimento web em Java e pela “mágica”
que seus frameworks trazem para o dia a dia de
nós desenvolvedores.Com mais de 10 anos de
experiência ajuda programadores do Brasil todo a se
tornarem profissionais.
Compartilhe e me siga nos
canais de conteúdo
Página Oficial | Grupo Oficial | Perfil Pessoal
Canal Youtube Oficial
Perfil Profissional
Java Avançado Cursos
sim! Iniciar o curso agora mesmo
clique aqui!
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 8
Agora eu vou mostrar para
você qual os caminhos
corretos para ser um
programador profissional.
A primeira regra que você deve seguir é NÃO
PULAR ETAPAS, programador é uma profissão
como qualquer outra e exige esforço, dedicação
e amor pelo que se faz, sentir prazer em ver o
resultado final e saber que foi você que criou
todo aquele sistema lindo e com um monte de
funcionalidades legais que impressionam qualquer
um e satisfaz o cliente 100 % porquê o cliente
final e o resultado final é o mais importante em
nossa profissão.
Quando falo não pular etapas imagina uma parede
de tijolos e se faltar tijolos essa parede desaba ou
até mesmo é impedida de ser construída. Essa é
a ideologia principal, temos que construir toda a
nossa base bem sólida, forte e fiel para poder ter
uma construção da nossa profissão perfeita.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 11
Aula Gratuita ― Como funciona
um sistema Web?
Como funciona um sistema web?. Um sistema web
funciona diferente de um sistema desktop é claro,
mas você sabe como?.
Então CLIQUE AQUI para assista a aula.
Mentalidade de programador
Desenvolver a capacidade
de resolver problemas
Lógica de programação
Algoritmos
Mentalidade
de
Programador
Primeiro de tudo antes de aprender uma linguagem
de programação devemos adquirir a mentalidade
de programador ou pensar e entender como
conversar e dar instruções ou comando para o
computador realizar as tarefas do jeito que nós
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 12
queremos e assim ter um resultado final correto
para um determinado trabalho do dia a dia.
Nesse processo inicial as duas coisas mais
importantes são a lógica de programação e o
entendimento de algoritmos.
Foque muito na Lógica de
Programação
Lógica de Programação é a técnica de desenvolver
sequências lógicas para atingir um determinado
objetivo. Essas sequências lógicas são adaptadas
para linguagem de computador pelo programador
a fim de produzir software com determinada
linguagem que em nosso caso é Java.
Uma sequência lógica é denominada algoritmo.
Então podemos dizer em linguagem mais coloquial,
que um algoritmo é uma sequência de passos para
atingir um determinado objetivo. Como podemos
ver a lógica de programação trata basicamente de
construir algoritmos que serão transformados em
programas de computador.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 13
Saber lógica de programação é saber o melhor
jeito de escrever um código, para o computador
interpretar corretamente. É saber se comunicar
com a máquina a partir de uma linguagem seja lá
qual for.
Quem quer começar uma carreira como
programador deve primeiro aprender lógica de
programação. Uma base sólida em lógica garante
ao iniciante conhecimentos suficientes para
aprender qualquer linguagem de programação.
Foque no aprendizado
de algoritmos
Um algoritmo nada mais é do que uma receita que
mostra passo a passo os procedimentos necessários
para a resolução de uma tarefa. Ele não responde
a pergunta “o que fazer?”, mas sim “como fazer”.
Em termos mais técnicos, um algoritmo é uma
sequência lógica, finita e definida de instruções
que devem ser seguidas para resolver um problema
ou executar uma tarefa.
Embora você não perceba, utiliza algoritmos de
forma intuitiva e automática diariamente quando
executa tarefas comuns. Como estas atividades são
simples e dispensam ficar pensando nas instruções
necessárias para fazê-las, o algoritmo presente
nelas acaba passando despercebido. Por exemplo,
quando precisa trocar uma lâmpada, você:
Java Web Formação Completa
Início:
 Verifica se o interruptor está desligado;
 Procura uma lâmpada nova;
 Pega uma escada;
 Leva a escada até o local;
 Posiciona a escada;
 Sobe os degraus;
 Para na altura apropriada;
 Retira a lâmpada queimada;
 Coloca a lâmpada nova;
 Desce da escada;
 Aciona o interruptor;
 Se a lâmpada não acender, então:
 Retira a lâmpada queimada;
 Coloca outra lâmpada nova;
 Senão
 Tarefa terminada;
 Joga a lâmpada queimada no lixo;
 Guarda a escada;
Fim;
Então acima acabamos de ver um exemplo de
algoritmo escrito em nossa linguagem que falamos,
mas o importante é entender que nesse processo
podemos definir como o sistema irá se comportar
e a partir dai transformamos o algoritmo em
um processo dentro de um sistema com alguma
linguagem que no nosso caso é Java.
Java Web Formação Completa
Seja especialista em apenas
uma linguagem
Sim, isso mesmo não acredite nas coisas loucas que
você encontra nos fóruns e blogs que existem por
ai à fora nesse mundão da internet dizendo que
programador tem que saber várias linguagens 2, 3,
4, não isso não é verdade.
Sabe como você sempre terá vagas de trabalhando
batendo a sua porta? Quando se tornar especialista
no que faz e quando falo isso é ser muito bom
mesmo em programação e focado em uma
linguagem, só pra lembrar eu estou a 10 anos
trabalhando com Java e vou falar a verdade para
você já criei dezenas de sistemas para muitas
empresas e tenho a certeza que não usei nem ao
menos 50% de todo o poder e utilidade que a
plataforma Java oferece.
Agora imagina se eu fosse aprender várias
linguagens ao mesmo tempo? Com certeza viraria
uma bagunça na minha mente e eu não seria
especialista apenas saberia uma pouco de cada
linguagem, mas só para relembrar que sendo
especialista você será procurado pelas empresas
e terá sucesso em sua carreira de programador,
então para concluir tenha foco em uma linguagem
e a estude em todas as suas melhores partes.
Java Web Formação Completa
Você precisa ter FOCO e
objetivo
Quando eu falo FOCO como eu citei acima o foco
deve ser na linguagem que você escolheu para sua
carreira, dentro da linguagem de programação
serão escolhidos frameworks, ferramentas,
plataforma de desenvolvimento (IDE), banco de
dados e principalmente o seu objetivo o que você
quer alcançar?
1. Ser um programador Desktop?
2. Atuar no desenvolvimento Web?
3. Criar aplicativos Mobile?
4. Ser desenvolvedor front-end?
5. Ser desenvolvedor back-end?
6. Ser um desenvolvedor full-stack?
7. Ser um profissional cloud computing?
8. Ser um profissional de banco de dados?
9. Ou todas as 8 áreas juntas?
Java Web Formação Completa
Calma, tudo de uma vez não dá não, lembre do
que já falamos  Não pule etapas!
Vou citar um exemplo, o Spring Framework é
o maior framework Java do mundo, ele abrange
todos os módulos de desenvolvimento é o
ecossistema completo tendo todas as ferramentas e
módulos que auxiliam o desenvolvedor Java a criar
aplicações com agilidade, qualidade, performance,
mas você deve estar me perguntando onde entra a
parte do FOCO.
Aqui que está a coisa mais importante, o Spring
Framework é o mais usado pelas empresas
de desenvolvimento de sistemas, praticamente
90% das vagas de empregos para Java pedem
obrigatoriamente conhecimentos aprofundados
nele e, com certeza, você não aprende em 1
semana, 1 mês ou 5 meses.
Aqui vai a verdade nua e crua doa a quem doer,
para se aprender e dominar muito bem um
frameworks gigantesco como esse é preciso de
em média 2 anos para se sentir confortável e
desenvolver com tranquilidade sem contar o tempo
para aprender programação básica.
Então é preciso foco, escolher o que aprenderá
levando em consideração o que o mercado mais
usa, quantidade de vagas de emprego e qualidade
em desenvolvimento, escolhendo as ferramentas
agora entra o foco nos estudos porque nesse
ponto você já sabe que sendo especialista na
linguagem e nas melhores ferramentas usadas pelo
mercado de trabalho você abrirá as portas para sua
carreira e se tornando um profissional de verdade
seguindo uma linha de estudo com muito foco
sabendo onde quer chegar.
Java Web Formação Completa
O foco é mais importante ainda quando
começamos a se deparar com muitos problemas o
que é normal em qualquer linguagem, ferramenta
e framework de desenvolvimento, cabe a você
pesquisar, aprender e solucionar, a última coisa
que deve pensar é partir para outro framework
por causa de um problema ou outro, tudo tem
solução você tem que aprender a usar, entender
o frameworks pra resolver problemas e entregar o
sistema para o cliente.
Você acha mesmo que tudo que irei te ensinar no
meu curso de Formação em Java Web
eu aprendi em 1 ano, 2 anos ou pior ainda
6 meses? Nunca, todo o conhecimento que
estou passando levaram 10 anos pra serem
adquiridos e eu juro que quando entrei pra
estudar programação eu não sabia o que era Java
e demorei 2 anos pra fazer o primeiro cadastro
em um sistema e olha só, hoje sou especialista e
estou aqui ensinando tudo a você dê uma forma
prática, fácil e diferente, entregando todo meu
conhecimento passo a passo em cima de todas as
dificuldades que já passei e sei que você também
passará e com o meu curso tudo ficará mais fácil.
Lembre-se, FOCO, dedicação, paciência, estudo e
assim você terá sucesso como eu.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 19
Abuse do aprendizado em
programação orientada a
objetos (POO)
A programação Orientada a objetos (POO) é uma
forma especial de programar, mais próximo de
como expressaríamos as coisas na vida real do que
outros tipos de programação.
Com a POO temos que aprender a pensar as coisas
de uma maneira distinta, para escrever nossos
programas em termos de objetos, propriedades,
métodos e outras coisas que veremos rapidamente
para esclarecer conceitos e dar uma pequena base
que permita soltarmos um pouco com este tipo de
programação.
Muitas linguagens estão se tornando orientadas
a objetos e pegando mesmo caminho que o Java,
mas o Java já nasceu orientado a objetos? Sim,
isso é verdade o que podemos ver é que conceitos
que existem a mais de anos no Java estão sendo
implementados agora em novas linguagens ou
atualizações de linguagens antigas mas que são
forte no mercado como o Grovy é igual ao Java.
Uma coisa é, Java já nasceu estando muitos anosluz a frente de qualquer outra linguagem existente
até o momento.
Uma coisa interessante é que você se tornando
ótimo em orientação a objetos fica muito mais
fácil você entender outras linguagens que estão
surgindo no mercado.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 20
E Java e sua orientação a objetos só é aprendida
colocando a mão na massa mesmo, trabalhando
ou mesmo faça um desafio a você mesmo, coloque
como objetivo para você aprender a criar um
sistema como esses aqui do vídeo  CLIQUE
AQUI PARA ASSISTIR.
Agora vamos falar do assunto
mais importante. Por onde
começar no Java Web?
Você está na faculdade e o professor começou
a falar de Java Web e um monte de coisas que
não entram em sua cabeça e te deixa perdido
sem rumo e o pior ainda, quando busca ajuda
nos fóruns e grupos do Facebook a confusão
só aumenta com a enxorada de informações
desencontradas e confusas que cada pessoa fala
uma coisa diferente e só piora a situação.
Pois é, eu acompanho vários grupos e fóruns e vejo
que as respostas em grande maioria só confunde
mais ainda a pessoa que está buscando o caminho
correto para aprender Java Web e entrar no
mercado de trabalho.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 21
Haaaa! E imagina a sorte que você tem por ler esse
texto. Eu tive sorte o suficiente pra trabalhar em
várias empresas do Brasil e pegar projetos em todas
as plataformas do Java e assim nesses mais de 10
anos de carreira eu aprendi degrau por degrau os
pilares para ser programador sênior em Java Web.
E eu percebi que a minha dificuldade era a mesma
de muitos e por influência da vida eu consegui
aprender todos os pilares necessários e sempre tive
em minha mente que um dia criaria meu site (que
você pode conhecer CLICANDO AQUI) e um
curso para ensinar todo mundo de uma forma fácil
e do jeito que eu aprendi.
Cansei de vasculhar blog, sites e baixar projetos
que nunca funcionavam e de repente eu conseguia
criar aquele código mas não tinha muito a ver com
as coisas na internet então sempre me vinha a
mente que disponibilizaria todo esse conhecimento
para fazer os outros sofrerem menos nessa carreira.
Olhe esse mapa mental simplificado abaixo:
Momento atual
Início
Webservices
Html
JavaScript
SQL
Swing
Android
API REStful e spring REStful Hibernate + Jpa + Ajax
Jsf e PrimeFaces Hibernate + Jpa + Ajax
Jsp e Spring Mvc Hibernate + Jpa + jQuery
Jsp e Servlets SQL + JDBC
O mundo
Java Web
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 22
Nós temos 4 grandes módulos mostrando a
evolução de baixo para cima que você deve
aprender:
1. A linha azul que representa JavaServer Pages
(JSP) e Servlets que é a base em Java Web e o que
for aprendido aqui será levado para sempre na
sua carreira é neste ponto que construiremos a
sua base.
2. A linha verde-escuro que representa JavaServer
Pages (JSP) e Spring Framework com arquitetura
MVC e contá também com o famoso jQuery
que nos dá o poder do Ajax e também o
Hibernate com JPA que nos dá o grande poder
de persistência com banco de dados diminuindo a
complexidade do SQL.
3. A linha verde-claro representa os frameworks
baseados em componentes e feitos para criar
aplicações ricas e com alta produtividade sendo
eles JavaServer Faces (JSF) e sua biblioteca
principal o PrimeFaces.
4. E na linha amarela representa as APIs RESTful que
são tecnologia de ponta onde aplicações nessa
estrutura pode ser reusadas e seus do back-end
pode ser usando para desktop, apps mobile e
navegadores web, neste momento o uso do JSON
explode mundialmente.
E podemos ver que html, css, javascript, sql e
webservices seguem acompanhando toda essa
evolução desde do início e assim continuará porque
são a base para se aprender qualquer frameworks web,
lembra da base, não pular etapas e construir a base.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 23
Cada módulo citado acima são arquiteturas
diferentes, estruturas de projetos e
desenvolvimentos e isso influência muito no
modo de pensar em como programar a aplicação
e como criar as funcionalidades dentro dela e o
mais importante ainda como fazer os frameworks
se conectarem e trafegarem dados da tela para o
banco de dados e vice-versa.
Modelo mental → JavaServe
Pages (JSP)
Fundamentos da Web/Internet
Java e orientação a objetos
SQL e JDBC básico
Html básico
JavaScript básico
CSS básico
Geral
Back-end
Front-end
JavaServer Pages (JSP)
(Front-end)
Servlets (Servidor)
(Back-end)
JSP
e
Servlets
Modelo mental → JavaServe Pages
(JSP) e Spring MVC
fundamentos da Web/Internet
Java e orientação a objetos
SQL e JDBC básico
Spring MVC
JavaScript básico
CSS básico
Html básico
JSP e
spring MVC
Hibernate
JPA
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 24
Modelo mental → JavaServer Faces
e frameworks
fundamentos da Web/Internet
Java e orientação a objetos
SQL e JDBC básico
Spring MVC
JavaScript básico
CSS básico
Html básico
JSF
Hibernate
JPA
Spring MVC PrimeFaces
JavaServer Faces
Modelo mental → Rest e RESTful
fundamentos da Web/Internet
Java e orientação a objetos
SQL e JDBC básico
Spring RESTful
JavaScript básico
CSS básico
Html básico
RESTful JSON
Arquitetura
Hibernate JPA
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional
| 25
Nossa, como aprenderei
tudo isso?
Muito simples, lembra no texto acima que eu disse
que é muita sorte você estar lendo esse texto?
Então foi para isso que eu criei o maior curso de
Java Web do Brasil e tenho muito orgulhos disso.
Hoje já passaram pelo meu treinamento mais de 2
mil pessoas que subiram na carreira e conseguiram
entrar no mercado de trabalho por causa dos
conhecimentos que adquiriram com o curso que criei.
Abaixo você pode conferir toda a grade curricular
e também já pode se inscrever e começar a estudar
agora mesmo no link
 CLIQUE AQUI PARA
COMEÇAR O CURSO
.
sim! Iniciar o curso agora mesmo
clique aqui!
?
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 26
Depoimentos dos
alunos felizes
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 27
Mapa mental → Linha de estudos
Java Web
RESTful JSON e Framework RESTful e MVC
JSF e PrimeFaces e ORM
SQL e banco de dados
Web Services
JSP e Frameworks MVC
CSS
JavaScript
Algorítimos
Lógica de programação
Linha de estudo
Java e orientação a objetos
Escolha sua linguagem !!! ???
Início
JavaScript não é Java
Qual é a diferença entre o JavaScript e o Java?
A linguagem de programação JavaScript,
desenvolvida pela Netscape, Inc., não faz parte da
plataforma Java.
O JavaScript não cria applets ou aplicações
independentes. Na sua forma mais comum, o
JavaScript fica embutido nos documentos HTML e
pode fornecer níveis de interatividade para páginas
Web que não são acessíveis com um HTML simples.
Diferenças-chave entre o Java e o JavaScript:
Java é uma linguagem de Programação POO, ao passo
que Java Script é uma linguagem de Scripts POO.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 28
Java cria aplicações executadas em uma máquina
virtual ou em um browser, ao passo que o código
JavaScript é executado apenas em um browser.
O código Java precisa ser compilado, ao passo que
os códigos JavaScript estão totalmente em texto
atuando juntos com o navegador e páginas bem do
lado do cliente.
Com JavaScript sua maior importância é manipular
elementos html e acessa recursos por POST, GET,
JSON, iterações na página com o cliente, acessar
RESTful e outros.
JavaScript é a base para que você domine qualquer
outro frameworks que são baseados em JavaScript
como na imagem abaixo:
React
JQuery
Ember
Node
D3
Meteor
AngularJS e Angular
Backbone
JavaScript
é a base
para:
Os mais famosos no mercado são React, JQuery e
AngularJs.
Existem muitos outros frameworks baseados em
JavaScript acima estou citando apenas alum mais
famosos, mas não se assuste sabendo apenas
um deles você já se da muito bem na carreira de
programador e se quiser ser um programador FullStack  CLIQUE AQUI.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 29
O JavaScript é a língua franca da web. Cresceu
rapidamente não apenas por causa do que oferece,
mas também por causa da comunidade de código
aberto que a rodeia.
Os frameworks e bibliotecas acima mencionadas
são verificações obrigatórias para qualquer
desenvolvedor JavaScript.
Todos eles fornecem alguma forma de explorar
JavaScript e desenvolvimento front-end.
Essa parte também entra os web design voltados
para criação de sites web e portais.
Caso queria entras no mercado de sites e portais
o Curso de Web Design Completo | Aprenda Web
Design  CLIQUE AQUI.
Cascading Style Sheets (CSS)
É um simples mecanismo para adicionar estilo
(cores, fontes, espaçamento, etc.) a um documento
web. Em vez de colocar a formatação dentro do
documento, o CSS cria um link para uma página
que contém os estilos.
Basicamente o que o CSS faz é deixar o seu sistema
bonito, lindão mesmo, quanto mais conhecimento
em CSS mais bonita você conseguirá deixar a sua
aplicação.
Veja abaixo alguns dos mais famosos frameworks
CSS:
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 30
BootStrap
foundation
Bulma
Ulkit
Semantic UI
Material Design Lite
CSS
é a base
para:
Mais uma vez não fique desesperado com esse
mundo para se aprender, os mais famosos e mais
usados são o BootStrap e o Material Design Lite
Hoje é muito comum criarmos uma aplicação
inteira sem usar CSS puro, basicamente o que
fazemos é escolher o layout que precisamos para o
front-end, escolher nosso frameworks JavaScript e
criar a lógica no back-end com Java.
Assim nossa aplicação é desenvolvida com uma
aparência bonita e bem mais rapidamente.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 31
Frameworks MVC em Java Web
Model-view-controller (MVC), em português
modelo-visão-controlador, é um padrão de
arquitetura de software (não confundir com um
design pattern) que separa a representação da
informação da interação do usuário com ele. O
modelo (model) consiste nos dados da aplicação,
regras de negócios, lógica e funções.
O mundo Java Web é constituída por inúmeros
frameworks que nos ajudam e nos dão muitos
recursos completos para desenvolvermos nossas
aplicações da melhor forma possível.
Abaixo o gráfico mostra os que são mais populares
do mercado a nível mundial:
Spring MVC
JSF
Vaadin
GWT
Grails
Other
0 5 10 15 20 25 30 35 40
21%
16%
10%
7%
6%
Nesse gráfico temos na liderança e isso não é de
agora, Spring MVC e JSF já lideram a mais de anos
esse mercado de desenvolvimentos em aplicações
corporativas para grandes empresas.
Em nosso curso iremos focar no Spring MVC e JSF
e vamos aprender do básico ao avançado o que
garantirá que as portas do mercado de trabalho se
abram pra você e isso eu garanto 100%.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 32
Então não perca tempo e muito menos o valor
promocional do curso. Clique no botão abaixo:
sim! Iniciar o curso agora mesmo
clique aqui!
Frameworks ORM Hibernate
e JPA
Mapeamento objeto-relacional (ou ORM, do
inglês: Object-relational mapping) é uma técnica
de desenvolvimento utilizada para reduzir a
impedência da programação orientada aos objetos
utilizando bancos de dados relacionais.
As tabelas do banco de dados são representadas
através de classes e os registros de cada tabela
são representados como instâncias das classes
correspondentes.
Com esta técnica, o programador não precisa se
preocupar com os comandos em linguagem SQL;
ele usará uma interface de programação simples
que faz todo o trabalho de persistência.
Não é necessária uma correspondência direta entre
as tabelas de dados e as classes do programa.
A relação entre as tabelas onde originam os dados
e o objecto que os disponibiliza é configurada pelo
programador, isolando o código do programa das
alterações à organização dos dados nas tabelas do
banco de dados.
A forma como este mapeamento é configurado
depende da ferramenta que estamos a usar. Como
exemplo, o programador que use Hibernate na
linguagem Java pode usar arquivos XML ou o
sistema de anotações que a linguagem providencia.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 33
Hibernate
O Hibernate é um framework para o mapeamento
objeto-relacional escrito na linguagem Java,
mas também é disponível em .Net com o nome
NHibernate.
JPA → Java Persistence API
Java Persistence API (ou simplesmente JPA) é uma
API padrão da linguagem Java que descreve uma
interface comum para frameworks de persistência
de dados.
A JPA define um meio de mapeamento objetorelacional para objetos Java simples e comuns
(POJOs), denominados beans de entidade.
Web Services em Java Web
Web Service é uma solução utilizada na integração
de sistemas e na comunicação entre aplicações
diferentes. Com esta tecnologia é possível que
novas aplicações possam interagir com aquelas
que já existem e que sistemas desenvolvidos em
plataformas diferentes sejam compatíveis.
Os Web Services são componentes que permitem
às aplicações enviar e receber dados.
Cada aplicação pode ter a sua própria
“linguagem”, que é traduzida para uma linguagem
universal, um formato intermediário como XML,
Json, CSV, etc.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 34
Para as empresas, os Web Services podem
trazer agilidade para os processos e eficiência
na comunicação entre cadeias de produção ou
de logística. Toda e qualquer comunicação entre
sistemas passa a ser dinâmica e principalmente
segura, pois não há intervenção humana.
Essencialmente, o Web Service faz com que
os recursos da aplicação do software estejam
disponíveis sobre a rede de forma normalizada.
Outras tecnologias fazem a mesma coisa; por
exemplo, os browsers da Internet acessam as
páginas Web disponíveis usando por norma as
tecnologias da Internet, HTTP e HTML.
No entanto, estas tecnologias não são bemsucedidas na comunicação e integração de
aplicações. Existe uma grande motivação sobre
a tecnologia Web Service pois possibilita que
diferentes aplicações comuniquem-se entre si e
utilizem recursos diferentes.
Utilizando a tecnologia Web Service, uma aplicação
pode invocar outra para efetuar tarefas simples
ou complexas mesmo que as duas aplicações
estejam em diferentes sistemas e escritas em
linguagens diferentes. Por outras palavras, os Web
Services fazem com que os seus recursos estejam
disponíveis para que qualquer aplicação cliente
possa operar e extrair os recursos fornecidos pelo
Web Service.
Os Web Services são identificados por um URI
(Uniform Resource Identifier), descritos e definidos
usando XML (Extensible Markup Language). Um
dos motivos que tornam os Web Services atractivos
é o facto deste modelo ser baseado em tecnologias
standards, em particular XML e HTTP (Hypertext
Transfer Protocol).
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 35
Os Web Services são utilizados para disponibilizar
serviços interativos na Web, podendo ser acessados
por outras aplicações usando, por exemplo, o
protocolo SOAP (Simple Object Access Protocol) ou
hoje em dia JSON mais RESTful.
Abaixo segue uma boa imagem que podemos
representar os web services ilustrando que podem
ser acessados por vários dispositivos diferentes.
Abaixo segue uma boa imagem que podemos
representar os web services ilustrando que podem
ser acessados por vários sistemas criados com
diferentes linguagens e dispositivos diferentes.
Web services
Java
.Net
PHP
Java
.Net
PHP
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 36
Banco de dados e SQL
Structured Query Language, ou Linguagem de
Consulta Estruturada ou SQL, é a linguagem de
pesquisa declarativa padrão para banco de dados
relacional (base de dados relacional).
Todos os bancos de dados relacionais suportam
consulta em SQL padrão.
Um banco de dados “é uma coleção de dados
inter-relacionados, representando informações
sobre um domínio específico”, ou seja, sempre que
for possível agrupar informações que se relacionam
e tratam de um mesmo assunto, posso dizer que
tenho um banco de dados.
Podemos exemplificar situações clássicas como uma
lista telefônica, um catálogo de CDs ou um sistema
de controle de RH de uma empresa.
Já um sistema de gerenciamento de banco de
dados (SGBD) é um software que possui recursos
capazes de manipular as informações do banco
de dados e interagir com o usuário. Exemplos de
SGBDs são: Oracle, SQL Server, DB2, PostgreSQL,
MySQL, o próprio Access ou Paradox, entre outros.
O objetivo final de um banco de dados a
armazenar todos os dados e que podem ser
acessados por uma aplicação.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 37
Banco de dados
Servidor
Clientes
Segurança em aplicações
Java Web
Para lançar aplicativos móveis, aplicações web,
softwares e sistemas de TI confiáveis, as empresas
devem ter um processo de desenvolvimento seguro
para resistir a ataques mal-intencionados. Este
processo envolve práticas seguras em cada fase do
desenvolvimento.
Em nosso curso aprenderemos Spring Security que
é o maior e mais usado no mundo inteiro.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 38
Frameworks de
Componentes e MVC
Talvez você ainda não conheça nada sobre isso, ou
talvez já ouviu falar, mas ainda está perdido e não
sabe como começar.
Hoje é muito comum JSF e PrimeFaces estar na lista
de pré-requisitos de boas vagas de emprego para
programadores Java.
Então, deixe eu te ajudar de uma vez por todas
para você começar hoje mesmo e se tornar um
programador melhor e mais requisitado! ;)
O que é JSF?
Antes de entender o que é PrimeFaces, você
precisa saber o que é JSF (JavaServer Faces).
JSF é uma tecnologia para desenvolvimento web
que utiliza um modelo de interfaces gráficas
baseado em eventos.
A tecnologia foi definida pelo JCP (Java
Community Process), que é o mecanismo que cria
especificações de tecnologias Java padronizadas.
Isso torna JSF um padrão de desenvolvimento e
facilita o trabalho dos fornecedores de ferramentas,
ao criarem produtos que valorizam a produtividade
no desenvolvimento de interfaces visuais.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 39
O que é PrimeFaces?
JSF fornece alguns componentes para os
desenvolvedores, como campos de entrada de
dados, botões, tabelas de dados, etc.
A grande questão é que esses componentes são
“puros”, simples, sem estilos visuais.
Isso não é um problema, se você quer criar o
layout do zero da sua aplicação e de todos os
componentes (ou ainda usar algum framework CSS
para isso, como Bootstrap).
Mas para quem busca alta produtividade e
qualidade visual praticamente sem trabalho extra,
precisa conhecer o PrimeFaces.
PrimeFaces é uma bibliotecas de componentes ricos
para aplicações criadas com JavaServer Faces.
É a biblioteca de componentes para JSF mais
popular no mundo!
Agora vou mostrar a você as
ferramentas e frameworks
que ensinarei no meu
treinamento de Formação em
Java Web Completa.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 40
Abaixo todas as tecnologias mais usadas no
mercado para desenvolvimento de sistemas em
Java para web, todas trabalhando juntas em só
projeto. Economize tempo tendo um projeto e
curso completo passo a passo sem perder tempo.
1. Spring Framework (MVC e RESTful)
Framework mais utilizado em todo mundo
em aplicações web, injeção de dependência,
controle de transações, arquitetura em MVC,
exemplos de arquitetura de serviçõs com
JQuery, Spring JDBC e trabalhando com JSF,
Ajax e arquitetura MVC.
2. Spring Security
Segurança em aplicações web, controle de
acesso a urls, acesso por papéis de cada
usuários.
3. JSF 2.2
Produtividade alta com componentes prontos,
construa páginas altamente funcionais com
pouco código, sendo produtivo com a facilidade
do JSF, realize ajax sem javascript de forma
simplificada.
4. PrimeFaces
Componentes customizados e integrados
com JSF, adicione componentes funcionais ao
projeto, este projeto web conta com um ótimo
exemplo de carregamento por demanda em
tabelas de dados nas páginas da aplicação.
5. IReport
Relatórios com a mais famosa ferramenta de
relatórios em Java.
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 41
6. JQuery
Facilitando as operações nas páginas e Ajax
super produtivo.
7. Facelets
Templates e componentes genéricos em JSF.
8. Hibernate
Alta produtividade com o mais famoso
frameworks de persistencia de dados.
9. JPA
Alta produtividade junto com o Hibernate.
10. Hibernate Envers
Gerencia o log de alterações de todos os
registro da base de dados.
11. Google Charts
Gráficos perfeitos com este frameworks da
Google.
12. FlyWay
E também da Google FlyWay gerencie versões
da sua base de dados e executa SQL que
você necessita para a sua aplicação durante a
inicialização da aplicação.
13. BootStrap
Bootstrap é um framework web com códigofonte aberto para desenvolvimento de
componentes de interface e front-end para
sites e aplicações web usando HTML, CSS e
JavaScript
Java Web Formação Completa
CLIQUE AQUI e se torne um programador profissional | 42
14. AngularJS
AngularJS é um framework JavaScript código
aberto, mantido pelo Google, que auxilia na
execução de single-page applications.
15. PgAdmin e SQL
O pgAdmin é um software gráfico para
administração do SGBD PostgreSQL disponível
para Windows e UNIX. É uma ferramenta
gráfica desenvolvida pela equipe de
desenvolvimento do PostgreSQL.
16. Eclipse e Apache Tomcat
Eclipse é a IDE mais utilizada juntos com o
servidor mais usado no mundo.
Então, o que está esperando pra aprender todo
esse conteúdo mais completo do Brasil? CLIQUE
AQUI
sim! Iniciar o curso agora mesmo
clique aqui!
Abraços de quem quer
seu sucesso!
Alex Fernando Egidio
Desenvolvedor Sênior em Java
Me siga nas redes sociais
Compartilha esse e-book com seus amigos, OK!
Tchau :)
Entre em contato comigo
javaavancado@javaavancado.com
alex.fernando.egidio@gmail.com
(45) 9 9979-5800
(44) 9 8821-2355
https://www.javaavancado.com
Cnpj: 26.934.453/0001-89
Rua: Pioneiro Antônio de Ganello
Bairro: Jardim Dias I
Cidade: Maringá/PR
Cep: 87025-758
Meu objetivo é fazer você entrar
no mercado de trabalho com todo
o conhecimento que tenho pra
passar a você.
sim! Iniciar o curso agora mesmo
clique aqui!
ATENÇÃO! AS VAGAS ESTÃO SE
ESGOTANDO RAPIDAMENTE!
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Desenvolvimento web Java
JSF + PrimeFaces
e Hibernate
Alex Fernando Egidio
Desenvolvedor Java Sênior
www.javaavancado.com
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Sumário
O que é Java EE?.............................................................................................................................5
O protocolo HTTP...........................................................................................................................6
Desenvolvimento web com Java......................................................................................................8
Containers........................................................................................................................................9
Introdução ao JSF e Primefaces.....................................................................................................10
Desenvolvimento desktop ou web?...............................................................................................11
O desenvolvimento Web e o protocolo HTTP...............................................................................12
Mesclando desenvolvimento Desktop e Web................................................................................13
Características do JSF....................................................................................................................13
Guarda o estado dos componentes.................................................................................................14
Separa as camadas.........................................................................................................................14
Especificação: várias implementações...........................................................................................14
Primeiros passos com JSF..............................................................................................................15
Configuração do controlador do JSF.............................................................................................17
Faces-config: o arquivo de configuração do mundo JSF...............................................................18
O que é ManagedBean?.................................................................................................................18
Principais componentes.................................................................................................................19
O que é o MVC Design Pattern?...................................................................................................20
Ciclo de vida do JSF......................................................................................................................20
Fase 1: Restore View (Restauração da visão)................................................................................22
Fase 2: Apply Request Values (Aplicar valores da requisição).....................................................22
Fase 3: Process Validation (Processar as validações)....................................................................22
Fase 4: Update Model Values (Atualizar valores de modelo)........................................................22
Fase 5: Invoke Application (Invocar aplicação)............................................................................23
Fase 6: Render Response (Renderizar a resposta).........................................................................23
Visão geral.....................................................................................................................................24
Anotações e Escopo.......................................................................................................................24
Estrutura de página JSF.................................................................................................................25
Configurando JSF com Maven......................................................................................................26
Ativando o JSF em nosso projeto..................................................................................................28
Configurando o Persistence.xml....................................................................................................29
Classe Java HibernateUtil..............................................................................................................29
Mapeando nossa entidade Usuário................................................................................................30
Estrutura padrão de um ManagedBean..........................................................................................32
PanelGrid em JSF e EL..................................................................................................................33
JSF – DataTable.............................................................................................................................34
Mensagens com FacesMessage.....................................................................................................34
Exibindo mensagens após redirecionamento.................................................................................35
CommandButton JSF.....................................................................................................................36
Quando usar Action ou ActionListener com JSF...........................................................................37
O Action.........................................................................................................................................37
O ActionListener............................................................................................................................38
O setPropertyActionListener.........................................................................................................39
Utilizando AJAX com JSF de maneira eficiente...........................................................................39
Visão geral do Ajax........................................................................................................................40
Utilizando Ajax com JSF...............................................................................................................41
Usando o FilterOpenSessionInView..............................................................................................42
Declarando Filter no Web.xml.......................................................................................................43
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Declarando o JPA/Hibernate no Filter...........................................................................................44
Tags Básicas...................................................................................................................................45
Parâmetros com JSF.......................................................................................................................45
Conhecendo show case JSF e PrimeFaces.....................................................................................46
Datatable se torna super fácil com PrimeFaces.............................................................................50
Gráficos com PrimeFaces..............................................................................................................53
Capturando erros com ExceptionHandler......................................................................................54
ExceptionHandler com Ajax..........................................................................................................55
ExceptionHandler sem Ajax..........................................................................................................57
Confirm Dialog..............................................................................................................................58
Confirm DialogGMap – Basic.......................................................................................................59
Barcode..........................................................................................................................................60
Chamadas de Ajax periódicas........................................................................................................60
Growl do PrimeFaces.....................................................................................................................61
Download do manual do PrimeFaces............................................................................................62
Referências.....................................................................................................................................63
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Alex Fernando Egidio
Autor, criador e fundador do Java Avançado Cursos TI. Atua no mercado como
desenvolvedor e engenheiro de sistemas em Java é apaixonado por desenvolvimento
web em Java e pela “mágica” que seus frameworks trazem para o dia a dia de nós
desenvolvedores.
Com mais de 10 anos de experiência ajuda programadores do Brasil todo a se
tornarem profissionais.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
O que é Java EE?
A Java EE (Java Platform, Enterprise Edition) é uma plataforma padrão para
desenvolver aplicações Java de grande porte e/ou para a internet, que inclui
bibliotecas e funcionalidades para implementar software Java distribuído, baseado em
componentes modulares que executam em servidores de aplicações e que suportam
escalabilidade, segurança, integridade e outros requisitos de aplicações corporativas
ou de grande porte.
A plataforma Java EE possui uma série de especificações (tecnologias) com objetivos
distintos, por isso é considerada uma plataforma guarda-chuva. Entre as
especificações da Java EE, as mais conhecidas são:
• Servlets: são componentes Java executados no servidor para gerar conteúdo
dinâmico para a web, como HTML e XML.
• JSP (JavaServer Pages): uma especialização de Servlets que permite que
aplicações web desenvolvidas em Java sejam mais fáceis de manter. É similar às
tecnologias como ASP e PHP, porém mais robusta por ter todas as facilidades da
plataforma Java.
• JSF (JavaServer Faces): é um framework web baseado em Java que tem como
objetivo simplificar o desenvolvimento de interfaces (telas) de sistemas para a web,
através de um modelo de componentes reutilizáveis. A proposta é que os sistemas
sejam desenvolvidos com a mesma facilidade e produtividade que se desenvolve
sistemas desktop (até mesmo com ferramentas que suportam clicar-e-arrastar
componentes).
• JPA (Java Persistence API): é uma API padrão do Java para persistência de
dados, que usa um conceito de mapeamento objeto-relacional. Essa tecnologia traz
alta produtividade para o desenvolvimento de sistemas que necessitam de integração
com banco de dados. Só para citar, essa API possibilita que você desenvolva
aplicações usando banco de dados sem precisar escrever uma linha sequer de SQL.
• EJB (Enterprise Java Beans): são componentes que executam em servidores
de aplicação e possuem como principais objetivos, fornecer facilidade e
produtividade no desenvolvimento de componentes distribuídos, transacionados,
seguros e portáveis.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
O protocolo HTTP
O protocolo HTTP é utilizado na navegação de páginas da Internet. Quando você
abre uma janela de um browser, acessa uma página Web e navega em seus links, você
está, na verdade, utilizando esse protocolo para visualizar, em sua máquina, o
conteúdo que está armazenado e/ou é processado em servidores remotos.
O HTTP é um protocolo stateless de comunicação cliente-servidor: o cliente envia
uma requisição para o servidor, que processa a requisição e devolve uma resposta
para o cliente, sendo que, a princípio, nenhuma informação é mantida no servidor em
relação às requisições previamente recebidas.
Assim, quando digitamos o endereço de uma página em um browser, estamos
gerando uma requisição a um servidor, que irá, por sua vez, devolver para o browser
o conteúdo da página HTML requisitada.
A requisição enviada por um cliente deve conter, basicamente, um comando (também
chamado de método), o endereço de um recurso no servidor (também chamado de
path) e uma informação sobre a versão do protocolo HTTP sendo utilizado.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Supondo, por exemplo, que queremos buscar o conteúdo do endereço
http://www.uol.com.br/index.html. Utilizemos o método GET, o path /index.html e a
versão 1.1 do protocolo HTTP. Temos a seguinte requisição enviada:
GET /index.html HTTP/1.1
Host: www.uol.com.br
Existem diversos métodos HTTP que podem ser especificados em requisições, sendo
os mais comuns o método GET, normalmente utilizado para obter o conteúdo de um
arquivo no servidor, e o método POST, utilizado para enviar dados de formulários
HTML ao servidor.
Uma requisição pode conter parâmetros adicionais, chamados headers. Alguns
headers comuns são, por exemplo, Host, User-Agent e Accept.
Uma vez processada a requisição, o servidor, por sua vez, manda uma resposta para o
cliente, sendo que essa resposta também tem um formato pré-determinado: a primeira
linha contém informações sobre a versão do protocolo, um código de status da
resposta e uma mensagem associada a esse status.
Em seguida, são enviados os headers da resposta, e finalmente, é enviado o conteúdo
da resposta. Veja um exemplo simples de resposta HTTP:
HTTP/1.1 200 OK
Date: Thu, 26 Sep 2013 15:17:12 GMT
Server: Apache/2.2.15 (CentOS)
Content-Type: text/html; charset=utf-8
<html>
 <body>
 </body>
</html>
No exemplo anterior, o código de status 200 indica que houve sucesso no
atendimento da requisição enviada pelo cliente, e os headers indicam a data e hora do
servidor, o servidor usado, tipo do conteúdo e, por fim, temos o código-fonte da
página HTML.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Outros códigos de status bastante comuns são o 404, que indica que o recurso não foi
localizado no servidor e o código 500, que indica que houve erro no processamento
da requisição enviada.
Desenvolvimento web com Java
Com o avanço da tecnologia sobre redes de computadores e com o crescimento da
internet, as páginas web estão se tornando cada vez mais atraentes e cheias de
recursos que aumentam a interatividade com o usuário.
Quando falamos em aplicações web, estamos nos referindo a sistemas ou sites onde
grande parte da programação fica hospedada em servidores na internet, e o usuário
(cliente) normalmente não precisa ter nada instalado em sua máquina para utilizá-las,
além de um navegador (browser).
O acesso às páginas desses sistemas é feita utilizando o modelo chamado de request e
response, ou seja, o cliente solicita que alguma ação seja realizada (request) e o
servidor a realiza e responde para o cliente (response).
Na plataforma Java, esse modelo foi implementado através da API de Servlets. Um
Servlet estende a funcionalidade de um servidor web para servir páginas dinâmicas
aos navegadores, utilizando o protocolo HTTP.
No mundo Java, os servidores web são chamados de Servlet Container, pois
implementam a especificação de Servlet. O servidor converte a requisição em um
objeto do tipo HttpServletRequest. Este objeto é então passado aos componentes web,
que podem executar qualquer código Java para que possa ser gerado um conteúdo
dinâmico.
Em seguida, o componente web devolve um objeto HttpServletResponse, que
representa a resposta ao cliente. Este objeto é utilizado para que o conteúdo gerado
seja enviado ao navegador do usuário.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Containers
Containers são interfaces entre componentes e funcionalidades de baixo nível
específicas de uma plataforma. Para uma aplicação web desenvolvida em Java ou
um componente corporativo ser executado, eles precisam ser implantados em um
container.
Os containers também são chamados de servidores de objetos, ou servidores de
aplicação, pois oferecem serviços de infra-estrutura para execução de componentes.
O EJB Container suporta Enterprise JavaBeans (EJB), que são componentes
corporativos distribuídos. Os Servlets, JSP, páginas JSF e arquivos estáticos (HTML,
CSS, imagens e etc) necessitam de um Web Container para ser executado.
Existem diversas organizações que desenvolvem containers Java EE, por exemplo:
Oracle, IBM, Red Hat, Apache, etc. Apesar de tantas ofertas gratuitas, algumas
empresas ainda vendem licenças de seus próprios servidores, pois oferecem suporte
diferenciado ao cliente e normalmente implementam funcionalidades que os
servidores gratuitos talvez não possuam.
Para testar nossos exemplos, usaremos o Apache Tomcat, pois é leve, gratuito e muito
popular.
Como estes servidores são baseados nas especificações da tecnologia Java EE,
teoricamente, você pode implantar os exemplos que desenvolveremos neste livro em
qualquer container compatível com a Java EE.
O download do Apache Tomcat pode ser feito em http://tomcat.apache.org.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Introdução ao JSF e Primefaces
Durante muitos anos, os usuários se habituaram com aplicações Desktop. Este tipo de
aplicação é instalada no computador local e acessa diretamente um banco de dados ou
gerenciador de arquivos.
As tecnologias típicas para criar uma aplicação Desktop são Delphi, VB (Visual
Basic) ou, no mundo Java, Swing. Para o desenvolvedor, a aplicação Desktop é
construída com uma série de componentes que a plataforma de desenvolvimento
oferece para cada sistema operacional.
Esses componentes ricos e muitas vezes sofisticado estão associados a eventos ou 
procedimentos que executam lógicas de negócio. Problemas de validação de dados
são indicados na própria tela sem que qualquer informação do formulário seja
perdida.
De uma forma natural, esses componentes lembram-se dos dados do usuário,
inclusive entre telas e ações diferentes. Nesse tipo de desenvolvimento são utilizados
diversos componentes ricos, como por exemplo, calendários, menus diversos ou
componentes drag and drop (arrastar e soltar).
Eles ficam associados a eventos, ou ações, e guardam automaticamente seu estado, já 
que mantêm os valores digitados pelo usuário.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Esses componentes não estão, contudo, associados exclusivamente ao
desenvolvimento de aplicações Desktop. Podemos criar a mesma sensação
confortável para o cliente em uma aplicação web, também usando componentes ricos
e reaproveitáveis.
Desenvolvimento desktop ou web?
Existem algumas desvantagens no desenvolvimento desktop. Como cada usuário tem
uma cópia integral da aplicação, qualquer alteração precisaria ser propagada para
todas as outras máquinas. Estamos usando um cliente gordo, isto é, com muita
responsabilidade no lado do cliente.
Note que, aqui, estamos chamando de cliente a aplicação que está rodando na
máquina do usuário. Para piorar, as regras de negócio rodam no computador do
usuário.
Isso faz com que seja muito mais difícil depurar a aplicação, já que não costumamos
ter acesso tão fácil à máquina onde a aplicação está instalada. Em geral, enfrentamos
problemas de manutenção e gerenciabilidade.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
O desenvolvimento Web e o protocolo HTTP
Para resolver problemas como esse, surgiram as aplicações baseadas na web. Nessa
abordagem há um servidor central onde a aplicação é executada e processada e todos
os usuários podem acessá-la através de um cliente simples e do protocolo HTTP.
Um navegador web, como Firefox ou Chrome, que fará o papel da aplicação cliente,
interpretando HTML, CSS e JavaScript que são as tecnologias que ele entende.
Enquanto o usuário usa o sistema, o navegador envia requisições (requests) para o
lado do servidor (server side), que responde para o computador do cliente (client
side).
Em nenhum momento a aplicação está salva no cliente: todas as regras da aplicação
estão no lado do servidor. Por isso, essa abordagem também foi chamada de cliente
magro (thin client).
Isso facilita bastante a manutenção e a gerenciabilidade, pois temos um lugar central
e acessível onde a aplicação é executada. Contudo, note que será preciso conhecer
HTML, CSS e JavaScript, para fazer a interface com o usuário, e o protocolo HTTP
para entender a comunicação pela web.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
E, mais importante ainda, não há mais eventos, mas sim um modelo bem diferente
orientado a requisições e respostas. Toda essa base precisará ser conhecida pelo
desenvolvedor.
Comparando as duas abordagens, podemos ver vantagens e desvantagens em ambas.
No lado da aplicação puramente Desktop, temos um estilo de desenvolvimento
orientado a eventos, usando componentes ricos, porém com problemas de
manutenção e gerenciamento. Do outro lado, as aplicações web são mais fáceis de
gerenciar e manter, mas precisamos lidar com HTML, conhecer o protocolo HTTP e
seguir o modelo requisição/resposta.
Mesclando desenvolvimento Desktop e Web
Em vez de desenvolver puramente para desktop, é uma tendência mesclar os dois
estilos, aproveitando as vantagens de cada um. Seria um desenvolvimento Desktop
para a web, tanto central quanto com componentes ricos, aproveitando o melhor dos
dois mundos e abstraindo o protocolo de comunicação. Essa é justamente a ideia dos
frameworks web baseados em componentes.
No mundo Java há algumas opções como JavaServer Faces(JSF), Apache Wicket,
Vaadin, Tapestry ou GWT da Google. Todos eles são frameworks web baseados em
componentes
Características do JSF
JSF é uma tecnologia que nos permite criar aplicações Java para Web utilizando
componentes visuais pré-prontos, de forma que o desenvolvedor não se preocupe
com Javascript e HTML. Basta adicionarmos os componentes (calendários, tabelas,
formulários) e eles serão renderizados e exibidos em formato html.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Guarda o estado dos componentes
Além disso o estado dos componentes é sempre guardado automaticamente (como
veremos mais à frente), criando a característica Stateful. Isso nos permite, por
exemplo, criar formulários de várias páginas e navegar nos vários passos dele com o
estado das telas sendo mantidos.
Separa as camadas
Outra característica marcante na arquitetura do JSF é a separação que fazemos entre
as camadas de apresentação e de aplicação. Pensando no modelo MVC, o JSF possui
uma camada de visualização bem separada do conjunto de classes de modelo.
Especificação: várias implementações
O JSF ainda tem a vantagem de ser uma especificação do Java EE, isto é, todo
servidor de aplicações Java tem que vir com uma implementação dela e há diversas
outras disponíveis.
A implementação mais famosa do JSF e também a implementação de referência, é a
Oracle Mojarra disponível em http://javaserverfaces.java.net/. Outra implementação
famosa é a MyFaces da Apache Soware Foundation em  http://myfaces.apache.org/.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Primeiros passos com JSF
A implementação Mojarra do JSF já define o modelo de desenvolvimento e oferece 
alguns componentes bem básicos. Nada além de inputs, botões e ComboBoxes
simples.
Não há componentes sofisticados dentro da especificação e isso é proposital: uma  
especificação tem que ser estável e as possibilidades das interfaces com o usuário 
crescem muito rapidamente.
A especificação trata do que é fundamental, mas outros projetos suprem o que falta. 
Para atender a demanda dos desenvolvedores por componentes mais sofisticados, há 
várias extensões do JSF que seguem o mesmo ciclo e modelo da especificação. 
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Exemplos dessas bibliotecas são PrimeFaces, RichFaces e IceFaces. Todas elas
denem componentes JSF que vão muito além da especificação.  
Cada biblioteca oferece ShowCases na web para mostrar seus componentes e suas
funcionalidades. Você pode ver o showcase do PrimeFaces no endereço
http://www.primefaces.org.
Na sua demo online, podemos ver uma lista de componentes disponíveis, como
inputs, painéis, botões diversos, menus, gráficos e componentes drag & drop, que vão 
muito além das especificações, ainda mantendo a facilidade de uso: 
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Para a definição da interface do projeto Argentum usaremos Oracle Mojarra com
PrimeFaces, uma combinação muito comum no mercado.
Configuração do controlador do JSF
O JSF segue o padrão arquitetural MVC (Model-View-Controller) e faz o papel do
Controller da aplicação. Para começar a usá-lo, é preciso configurar a servlet do JSF 
no web.xml da aplicação. Esse Servlet é responsável por receber as requisições e
delegá-las ao JSF. Para configurá-lo basta adicionar as seguintes configurações no  
web.xml:
Ao usar o Eclipse com suporte a JSF 2 essa configuração no web.xml já é feita 
automaticamente durante a criação de um projeto.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Faces-config: o arquivo de configuração do mundo JSF
Além disso, há um segundo XML que é o arquivo de configuração relacionado com o 
mundo JSF, o faces-config.xml. Como o JSF na versão dois encoraja o uso de
anotações em vez de configurações no XML, este arquivo torna-se pouco usado. Ele 
era muito mais importante na primeira versão do JSF. Neste treinamento, deixaremos
ele vazio:
O que é ManagedBean?
Um sistema de cadastro por exemplo, assim que o usuário terminar de digitar seus
dados e clicar em concluir o managedBeans irá receber estas informações e verificar
se tem algum erro e retornar uma página dizendo que o cadastro foi feito ou irá
retornar uma página informando os erros. O managedBean é o Controller neste caso.
A principal responsabilidade de um managedBean é intermediar a comunicação entre
as páginas (componentes do JSF) e nosso modelo. Escutar eventos, processá-los e
delegar para a camada de negócios são apenas algumas de suas responsabilidades.
A comunicação entre managedBeans não difere da troca de mensagens entre
componentes de software na orientação a objetos. Cada componente (managedBean)
conhece a interface pública do outro componente para que eles possam trocar
mensagens.
ManagedNeans são componentes, em sua grande maioria, intimamente ligados a(s)
página(s) e que deveriam ter apenas o estritamente necessário para representar a GUI.
Dificilmente você terá um managedBean genérico (CRUD não conta) que poderia
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
funcionar em todo lugar. Você precisa fazer um esforço hercúleo para conseguir isso,
e as vezes parece que não vale a pena.
Todo managedBean é ligado com uma tela diretamente e podemos identificar isso
através da anotação @ManagedBean.
Principais componentes
O verdadeiro poder de JavaServer Faces está em seu modelo de componentes de
interface do usuário, que gera alta produtividade aos desenvolvedores, permitindo a
construção de interfaces para web usando um conjunto de componentes pré
construídos, ao invés de criar interfaces inteiramente do zero.
Existem vários componentes JSF, desde os mais simples, como um Output Label, que
apresenta simplesmente um texto, ou um Data Table, que representa dados tabulares
de uma coleção que pode vir do banco de dados.
A API de JSF suporta a extensão e criação de novos componentes, que podem
fornecer funcionalidades adicionais. Os principais componentes que a implementação
de referência do JSF fornece são: formulário, campos de entrada de texto e senhas,
rótulos, links, botões, mensagens, painéis, tabela de dados, etc.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
O que é o MVC Design Pattern?
O padrão de design MVC projeta um aplicativo usando três módulos separados
• Model: Carrega dados do banco para a tela e da tela para o banco.
• View: São as telas que o usuário vê do sistema.
• Controller: Manipula o processamento do dados dados entre a tela e camada
de persistência.
O objetivo do padrão de design do MVC é separar o modelo e a apresentação,
permitindo que os desenvolvedores se concentrem em suas habilidades principais e
colaborem de forma mais clara.
Web designers têm que se concentrar apenas na camada de visão, em vez de camada
de modelo e controlador. Os desenvolvedores podem alterar o código do modelo e
normalmente não precisam alterar a camada de visualização.
Os controladores são usados para processar ações do usuário. Nesse processo, o
modelo e as visualizações da camada podem ser alterados.
Ciclo de vida do JSF
Um dos fundamentos de maior relevância do JSF é seu ciclo de vida que se dá entre a
requisição e a resposta do servidor de aplicação. São vários os motivos da existência
deste ciclo, dentre estes, temos:
• Manter o controle de estado dos componentes de interface;
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
• Alinhar ouvintes de eventos com seus respectivos eventos;
• Controle de navegação entre páginas, que deve ser realizado pelo servidor;
• Permitir que validações e conversões sejam realizadas no lado do servidor.
Indo direto ao assunto, o ciclo de vida do JSF se divide em seis fases (veja a figura
abaixo), que são:
• Fase 1: Restore View (Restauração da visão);
• Fase 2: Apply Request Values (Aplicar valores da requisição);
• Fase 3: Process Validation (Processar as validações);
• Fase 4: Update Model Values (Atualizar valores de modelo);
• Fase 5: Invoke Application (Invocar aplicação);
• Fase 6: Render Response (Renderizar a resposta).
Vejamos agora o que acontece em cada uma.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Fase 1: Restore View (Restauração da visão)
A partir de uma requisição proveniente do Servlet FacesServlet, é identificado qual
visão está sendo requisitada por meio do ID desta que é determinado pelo nome da
página JSF. Tendo identificado a página, esta é salva no FacesContext (caso ainda não
tenha sido salva) e sua respectiva árvore de componentes é construída.
Fase 2: Apply Request Values (Aplicar valores da requisição)
Fase 2: Apply Request Values (Aplicar valores da requisição) Nesta fase, cada
componente da visão, criado ou recuperado, passa a ter o seu valor. Nesse contexto,
existem algumas diferenças ocasionadas pelo valor do atributo “immediate” em cada
componente:
• immediate = false: Neste caso, que é o padrão, os valores são apenas
convertidos para o tipo apropriado. Se o valor é um Integer, é convertido para
Integer.
• immediate = true: Os valores são convertidos e validos.
Fase 3: Process Validation (Processar as validações)
Esta é a primeira manipulação de eventos do ciclo, aqui serão executadas as
validações definidas pelo servidor em cada componente. Não existindo valores
inválidos, o ciclo segue para a Fase 4. Existindo, uma mensagem de erro será gerada
(adicionada ao contexto do Faces, FacesContext) e o componente é marcado como
inválido. Neste caso, o ciclo segue para a Fase 6 (Renderizar a resposta).
Fase 4: Update Model Values (Atualizar valores de modelo)
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Fase 4: Update Model Values (Atualizar valores de modelo) Os valores enviados pela
requisição e validados pela fase 3, são atualizados em seus respectivos atributos
contidos nos backings beans, onde somente as propriedades enviadas são atualizadas.
É importante dizer que, mesmo após a fase de validação, fase 3, os valores enviados
podem estar inválidos a nível de negócio ou a nível de conversão de tipos, o que pode
ser verificado pelo próprio bean.
Fase 5: Invoke Application (Invocar aplicação)
Nesta fase, os valores dos componentes da requisição, estão validados convertidos e
disponíveis nos backings beans. Assim a aplicação tem os insumos necessários para
aplicar a lógica de negócio.
Outro fator importante dessa fase, é o direcionamento do usuário de acordo com as
submissões realizadas pelo mesmo. Por exemplo, se ouve sucesso no processamento
dos dados enviados, o usuário é redirecionado para uma determinada página, se não,
permanece na mesma página.
Fase 6: Render Response (Renderizar a resposta)
O processo ‘Renderizar a resposta’ consiste na apresentação da página referente ao
resultado da aplicação ao usuário. Neste contexto existem três possibilidades:
• Caso seja a primeira requisição da página: Os componentes associados são
criados e associados a visão;
• Caso seja a primeira submissão: Os componentes são traduzidos para o HTML;
• Caso tenha ocorrido algum erro: Existindo os marcadores <f:message /> ou
<f:messages /> na página, os erros são exibidos ao usuário.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Visão geral
No desenvolvimento em JSF existem dois perfis diferentes de desenvolvedores: os
que desenvolveram aplicações JSF e os que desenvolveram componentes. No
primeiro perfil, as fases de maior foco são a 2, 3, 4 e 5. Já no segundo, são a 1 e 6,
que estão mais relacionadas a árvore de componentes no lado do servidor e de
componentes da visão. Sendo assim podemos agrupar as fases da seguinte forma:
• Fases focadas no desenvolvimento de aplicações JSF
• Fase 2: Apply Request Values (Aplicar valores da Requisição)
• Fase 3: Process Validation (Processar as Validações)
• Fase 4: Update Model Values (Atualizar Valores de Modelo)
• Fase 5: Invoke Application (Invocar Aplicação)
• Fases focadas no desenvolvimento de componentes de visão
• Fase 1: Restore View (Restauração da Visão)
• Fase 6: Render Response (Renderizar a Resposta)
Anotações e Escopo
Anotações de escopo definem o escopo no qual o bean gerenciado será colocado. Se
o escopo não for especificado, o bean será padronizado escopo de @Request.
Quando referenciamos um managedBean via EL, o framework do JSF instanciará um
objeto da classe do managedBean, ou recuperará uma instância existente. Todas as
instâncias possuem um tempo de vida, que é definido dependendo do escopo usado
no managedBean. Os escopos de managedBeans JSF podem ser definidos através de
anotações do pacote javax.faces.bean. Os principais são:
@NoneScoped: o bean será instanciado a cada vez que for referenciado.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
@RequestScoped (padrão): tem vida curta, começando quando é referenciado em
uma única requisição HTTP e terminando quando a resposta é enviada de volta ao
cliente.
@ViewScoped: a instância permanece ativa até que o usuário navegue para
uma próxima página.
@SessionScoped: mantém a instância durante diversas requisições e até mesmo
navegações entre páginas, até que a sessão do usuário seja invalidada ou o tempo
limite é atingido. Cada usuário possui sua sessão de navegação, portanto, os objetos
não são compartilhados entre os usuários.
@ApplicationScoped: mantém a instância durante todo o tempo de execução da
aplicação. É um escopo que compartilha os objetos para todos os usuários do sistema.
Estrutura de página JSF
As páginas em JSF são estruturas em XML, no início sempre ficam declarados as
bibliotecas e a referência deles para as tags JSF.
Logo após teremos sempre o HEAD que é o nosso cabeçalho, onde são definidos
CSS, JavaScript, titulo e outros recursos.
E a coisa mais importante que você deve saber é que para o JSF funcionar todos os
elementos devem estar dentro do FORM e o este dentro do BODY.
Tendo está estrutura inicial dentro do FORM será onde criaremos toda a estrutura de
uma página, por exemplo um cadastro de pessoa.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Configurando JSF com Maven
Para usarmos nosso projeto JSF precisamos não apenas do JSF e também precisamos
do Hibernate, PostgreSQL, PrimeFaces e para isso tem que ser baixado uma lista
enorme de bibliotecas o principal beneficio do Maven é isso baixar tudo que precisa
de uma vez e com versões compatíveis.
Pra começar as configurações vou listar abaixo o código XML do pom.xml do
Maven.
Configurando PostgreSQL com Maven.
Configurando o Hibernate + JPA com Maven.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Configurando JSF com Maven.
Configurando PrimeFaces com Maven.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Após configurar e salvar todas as alterações o Maven irá automaticamente baixar da
inter todas as bibliotecas/JAR do Java e dos frameworks para podemos iniciar nosso
projeto.
Ativando o JSF em nosso projeto
Para o nosso projeto Java enxergar o uso do JSF em nosso projeto temo que ativar o
FacesServlet em nosso projeto, essa classe e a principal do JSF.
FacesServlet é um Servlet que gerencia o ciclo de vida de processamento de pedidos
para aplicativos da web que estão utilizando o JavaServer Faces para construir a
interface com o usuário.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Configurando o Persistence.xml
Nesse arquivo ficam as configurações do banco de dados e das classes mapeadas
como entidades de nosso projeto.
Classe Java HibernateUtil
Essa classe é responsável por ler o arquivo persistence.xml e criar a conexão com o
banco de dados e todos as opções configuradas.
Nesta mesma classe que é criado o EntityManagerFactory. Interface usada para
interagir com a fábrica do gerenciador de entidades para a unidade de persistência.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Quando o aplicativo terminar de usar a fábrica do gerenciador de entidades e / ou no
encerramento do aplicativo, o aplicativo deverá fechar a fábrica do gerenciador de
entidades.
Uma vez que um EntityManagerFactorytenha sido fechado, todos os seus gerentes de
entidade são considerados em estado fechado.
Mapeando nossa entidade Usuário
A Java Persistence API (JPA), parte da especificação EJB 3.0 do Java Enterprise
Edition 5, simplifica muito a persistência de Java e fornece uma abordagem de
mapeamento objeto-relacional que permite declarativamente definir como mapear
objetos Java para tabelas de banco de dados relacional de uma maneira padrão e
portátil que funciona tanto dentro de um servidor de aplicativos Java EE 5 quanto
fora de um contêiner EJB em um aplicativo Java Standard Edition 5 (Java SE 5).
Usando o JPA, você pode designar qualquer classe POJO como um JPA entidade -
um objeto Java cujos campos não transitórios devem ser mantidos em um banco de
dados relacional usando os serviços de um gestor da entidade obtido de uma
APP provedor de persistência (dentro de um contêiner EJB Java EE ou fora de um
contêiner EJB em um aplicativo Java SE).
Uma entidade tem as seguintes características:
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
• É compatível com o EJB 3.0;
• É leve;
• Ele gerencia dados persistentes em conjunto com um gerenciador de
entidades JPA;
• Realiza lógica de negócios complexa;
• Potencialmente usa vários objetos Java dependentes;
• Pode ser identificado exclusivamente por uma chave primária.
Entidades representam dados persistentes armazenados em um banco de dados
relacional automaticamente usando persistência gerenciada por contêineres. Eles são
persistentes porque seus dados são armazenados de forma persistente em alguma
forma de sistema de armazenamento de dados, como um banco de dados: eles
sobrevivem a uma falha de servidorou rede. Quando uma entidade é reinstânciada, o
estado da instância anterior é automaticamente restaurado.
Uma entidade modela uma entidade de negócios ou várias ações dentro de um único
processo de negócios. As entidades geralmente são usadas para facilitar os serviços
de negócios que envolvem dados e cálculos nesses dados. Por exemplo, você pode
implementar uma entidade para recuperar e executar cálculos em itens dentro de um
pedido de compra. Sua entidade pode gerenciar vários objetos persistentes
dependentes na execução de suas tarefas.
Entidades podem representar objetos persistentes refinados, porque não são
componentes remotamente acessíveis.
Uma entidade pode agregar objetos juntos e efetivamente persistir dados e objetos
relacionados usando os serviços transacionais, de segurança e de simultaneidade de
um provedor de persistência JPA.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Estrutura padrão de um ManagedBean
Todo ManagedBean por mais simples que seja o cadastro possui uma estrutura
padrão para o seu funcionamento.
Abaixo cito e demonstro em código esses pontos principais:
• Objeto de regra de negócio da tela.
• DAO de persistência.
• Lista que carrega os objetos cadastrados.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
PanelGrid em JSF e EL
A tag h:panelGrid renderiza um elemento "table" em HTML.
A nova versão da EL contempla adições significativas na linguagem de expressões,
principalmente por conta do suporte a expressões lambda e das funcionalidades para
manipulação de coleções inspiradas no modelo de programação funcional que está
sendo incorporado à Java SE 8.
A partir de agora os desenvolvedores poderão ordenar, filtrar e transformar coleções
de forma bastante simplificada utilizando a EL e expressões lambda.
Outro ponto bastante importante é que a EL 3.0 desacopla a linguagem de expressões
das tecnologias web (JSP e JSF) e cria um grande potencial ao trazer suas
funcionalidades para fora do container Java EE através da API standalone. Com essa
nova API os desenvolvedores poderão escrever e resolver expressões EL dentro do
bom e velho código Java.
Além dessas principais mudanças, a EL 3.0 traz outros recursos e melhorias à
linguagem de expressões a fim de atender pedidos antigos da comunidade e
maximizar a produtividade dos desenvolvedores. Entre essas melhorias estão a
introdução de novos operadores (incluindo um para concatenação de Strings) e o
acesso a construtores e membros estáticos de classes Java.
A forma que ligamos os atributos com os dados da página JSF com o managedBean é
pela expression language em JSF que é identificado pelo simbolo #{}.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
JSF – DataTable
O JSF fornece um controle avançado chamado DataTable para renderizar e formatar
tabelas html.
• DataTable pode iterar em uma coleção ou matriz de valores para exibir dados.
• O DataTable fornece atributos para modificar seus dados de maneira fácil.
Esse componente carrega os dados que estão em um managedBean e sempre
utilizamos uma lista para isso e no datatable o atributo value apontamos essa lista e
trabalhamos os dados com uma variável que representa o objeto ou item da lista.
Mensagens com FacesMessage
FacesMessage representa uma única mensagem de validação (ou outra), que é
normalmente associada a um componente específico na exibição. Uma FacesMessage
instância pode ser criada com base em um específico messageId. A especificação
define o conjunto de messageIds para os quais deve haver FacesMessage instâncias.
No formulário em JSF o componente que exibe as mensagens enviadas para o
FacesMessage é o h:messages.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Exibindo mensagens após redirecionamento
Para conseguir com que as mensagens sobrevivam ao redirecionamento, basta usar o
código abaixo:
Essa linha vai fazer com que suas mensagens sejam armazenadas no escopo de Flash.
A duração desse escopo vai ser o suficiente para que você consiga exibir as
mensagens adicionadas depois do redirecionamento.
O código completo do método ficaria assim:
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CommandButton JSF
A tag h: commandButton renderiza um elemento de entrada HTML do tipo "submit".
Usamos o commandButon para saber, atualizar, remover e consultar dados, ele faz o
envio do formulário para o lado do servidor e para isso é usado o atributo action onde
colocamos o método do managedBean que queremos chamar.
Então, para entendermos bem o processo quando clicamos no botão o JSF irá fazer
todas as validações necessários cado haja e enviará os dados para o lado do
managedBean e é nesse momento que os dados da tela são adicionados/setado para o
objeto que representa a tela e após seta o método irá ser chamado.
De acordo com os botões acima pode ver abaixo quais serão os método que serão
chamados.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Quando usar Action ou ActionListener com JSF
Basicamente temos duas formas de executar uma ação no managedBean após clicar
em um botão ou link com JSF. Podemos passar uma EL (Expression Language) para
o atributo action ou para o atributo actionListener do componente. Apesar de ambos
os atributos invocarem um método no managedNean, eles possuem uma diferença
sútil que costuma levar a pergunta: quando e qual devo usar?
Não é difícil decidir qual usar. Para isso precisamos antes entender a motivação por
trás de cada um e suas peculiaridades.
O Action
Você deveria usar uma action se sua intenção é executar uma lógica de negócio ou
navegar entre páginas. O método da action pode retornar uma String indicando a
regra de navegação.
Por exemplo, para executar uma lógica de negócio que grava um usuário no banco de
dados teríamos algo como:
E no managedBean teríamos este método:
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Repare que após gravar o usuário o managedBean executa uma regra de navegação
para que o usuário seja redirecionado para a página de listagem de usuários.
Esta regra de navegação é conhecida como outcome. Se o método retorna null ou
possui retorno void, o usuário é mantido na mesma página e o JSF reaproveita a
mesma árvore de componentes.
O mesmo pode ser obtido se uma String vazia é retornada ou o outcome retornado
leve para a mesma página, nesse caso a diferença é que uma nova árvore de
componentes é criada.
O ActionListener
Você deveria usar uma actionListener se o que você quer fazer é executar uma lógica
relacionada a view ou disparar uma ação antes de uma lógica de negócio.
A lógica invocada por uma actionListener está mais ligada a detalhes da tela do que
puramente regras de negócio. Para usá-lo em uma h:commandButton bastaria termos
o código a seguir:
A diferença principal entre o action eu actionListener é que o actionListener não faz
redirecionamento e nem envio do formulário e mesmo assim ainda podermos
executar métodos Java do lado o servidor.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
O setPropertyActionListener
No JSF, a tag “ f: setPropertyActionListener ” permite que você defina um valor
diretamente na propriedade do seu bean de apoio.
Quando vamos editar, excluir ou consultar um objeto em JSF é o
setPropertyActionListener que será usado, ele seta para o managedBean o objeto
selecionado em tela e conseguindo enviar o objeto que queremos para o lado do
servidor fica fácil criar qualquer rotina.
Utilizando AJAX com JSF de maneira eficiente
Inicialmente, as páginas WEBs eram desenvolvidas de maneira estática, ou seja, para
uma atualização refletir ao cliente, toda a página tinha que ser carregada. Com isso,
para atualizar algum pequeno conteúdo, obrigatoriamente o cliente precisava realizar
uma requisição, de maneira completa, a aplicação WEB.
Esse problema consiste quando se precisa atualizar repetidamente a aplicação,
podendo afetar o desempenho da mesma.
O Ajax veio para solucionar este tipo de problema.
Ajax é um conjunto de tecnologias para desenvolvimento WEB que permite que
possam ser desenvolvidas páginas dinâmicas, que respondam a algumas situações de
maneira assíncrona, sem que toda a aplicação seja atualizada. Com Ajax, as
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
aplicações webs podem recuperar informações do servidor de maneira altamente
responsiva com o cliente.
Visão geral do Ajax
Ajax é baseado em JavaScript e XML, tecnologias utilizadas para desenvolvimentos
de aplicações WEBs dinâmicas e assíncronas.
O funcionamento da tecnologia Ajax se baseia no seguinte processo, é enviada uma
solicitação assíncrona para o servidor, e este envia de volta uma resposta no modelo
DOM para atualizar a página.
Uma observação importante é que a comunicação cliente e servidor não se limitam
apenas ao modelo DOM, ela também pode utilizar o formato JSON.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Utilizando Ajax com JSF
AJAX significa asynchronous JavaScript and Xml.
Ajax é uma técnica para usar HTTPXMLObject de JavaScript para enviar dados para
o servidor e receber dados do servidor de forma assíncrona. Assim, usando a técnica
Ajax, o código javascript troca dados com o servidor, atualiza partes da página da
web sem recarregar a página inteira.
Para entender o funcionamento desta técnica, primeiro é necessário saber como
funciona o modelo cliente-servidor. Neste modelo, o cliente envia uma requisição ao
servidor e aguarda pela resposta, ou seja, solicita ao servidor para que ele processe
algo e espera por um retorno. O servidor processa essa requisição assim que ela
chega, e quando esta operação estiver concluída, uma resposta é gerada e enviada
para o cliente.
No caso do AJAX, o cliente referenciado no cenário acima, é o browser do usuário,
que executará o código escrito na linguagem JavaScript. Este é desenvolvido de
forma que dispare requisições para o servidor conforme o usuário interage com a
página. Essas requisições são assíncronas porque elas são enviadas para o servidor e
processadas de maneira não ordenada, ou seja, não possuem sincronia.
Assim que as requisições chegam ao servidor, elas são processadas, e ao finalizar o
processamento da requisição, uma reposta é gerada e enviada para o cliente,
geralmente em XML. Quando essa resposta chega ao cliente, o código JavaScript a
interpreta e atualiza os valores da página, caso necessário.
Nos dias de hoje existem vários frameworks que auxiliam no desenvolvimento de
aplicações AJAX. O JavaServer Faces é um deles, e em sua versão 2.0, passou a
suportá-lo nativamente. Deste modo, as requisições e os códigos JavaScript são
encapsulados dentro de componentes, logo, na maioria dos casos, não é necessário
escrever código em JavaScript.
O JSF fornece suporte excepcional para fazer chamadas ajax. Ele fornece tag f: ajax
para lidar com chamadas ajax.
A funcionalidade Ajax pode ser adicionada em uma aplicação JSF por meio da
importação de suas bibliotecas. Toda aplicação que fizer o seu uso estará representada
pela tag <f:Ajax>.
Duas opções são as mais importantes quando usamos ajax:
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Execute: que é o atributo onde especificamos o ID do componente que será enviado
para o lado do servidor.
Render: que é o atributo que identificamos o componente em tela que será
recarregado depois que o execute for processado.
Então supondo que queremos digitar um texto e esse mesmo texto ser recarregado em
outro componente temos o exemplo abaixo.
Usando o FilterOpenSessionInView
Um problema que todos que estão trabalhando com Hibernate não está livre de se
deparar com ele. É o velho LazyInitializationException que acontece e deixa o pobre
do desenvolvedor estressado.
Pretendo ser menos teórico e mais prático, pois tem muita coisa na net explicando o
porque temos o LazyInitializationException, porém poucos explicaram de forma
prática a solução.
Então aqui vou mostrar como resolver o problema, pois também fui afetado com este
problema e levei umas quase 15 horas para resolver. E agora vejo que era algo
simples, mas eu precisava entender o por que.
Além de resolver muitos problemas em projetos esse filtro resolve um grande
problema na parte de persistência de dados, porque pode estabelecer um ponto único
para abrir a sessão, commitar e dar roolback nas transações com o banco de dados e
isso mantém a consistência dos dados em uma base de dados do nossos sistemas.
Um segundo problema também que conseguimos resolver e que com esse filtro pode
fazer o Hibernate já subir a conexão e todas as configurações quando o servidor
estiver sendo estartado.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Então o que temos que fazer é criar uma classe e implementas a interface Filter, mas
especificamente do pacote javax.servlet.Filter do JavaEE e também anotar com
@WebFilter e por ultimo adicionar a sua declaração no arquivo web.xml para que
seja possível a leitura dele pelo projeto, esse padrão permite interceptar toda
requisição e responta em um único ponto do sistema.
Declarando Filter no Web.xml
Precisamos nos atentar a dois passos:
• Declarar o filter passando todo o caminho do pacote da classe para sua
identificação.
• Fazer o mapeamento de URL para o filter.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Outra opção é mapear com anotações que substituem as configurações no web.xml
Declarando o JPA/Hibernate no Filter
Primeiro passo é declarar o objeto EntityManager para usarmos em nosso filtro.
Dentro do nosso método doFilter que é chamado em todas as requisições e respostas
nós fazemos a verificação se a sessão está aberta e se sim executamos o SQL em
memória diretamente do banco com o flush() e damos o commit();
E por último fechamos a sessão. Temos que tratar qualquer erro que venha acontecer
em nosso sistema e para isso o filter que implementamos resolve muito bem qualquer
problema então caso venha acontecer algum erro dentro do Exception damos o
rollback para rever alterações no banco de dados feita na transação atual.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Tags Básicas
• h: inputText Processa uma entrada HTML de type = "text", caixa de texto.
• h: inputSecret Processa uma entrada HTML de tipo = "senha", caixa de texto.
• h: inputTextarea Processa um campo textarea HTML.
• h: inputHidden Processa uma entrada HTML de type = "hidden".
• h: selectBooleanCheckbox Processa uma única caixa de seleção HTML.
• h: selectManyCheckbox Processa um grupo de caixas de seleção de HTML.
• h: selectOneRadio Processa um único botão de opção HTML.
• h: selectOneListbox Processa uma caixa de listagem única em HTML.
• h: selectManyListbox Renderiza uma caixa de listagem múltipla em HTML.
• h: selectOneMenu Processa uma caixa de combinação HTML.
• h: outputText Processa um texto HTML.
• h: outputFormat Processa um texto HTML. Aceita parâmetros.
• h: graphicImage Processa uma imagem.
• h: outputStylesheet Inclui uma folha de estilo CSS na saída HTML.
• h: outputScript Inclui um script na saída HTML.
• h: commandButton Processa uma entrada HTML do botão type = "submit".
• h: Link Processa uma âncora HTML.
• h: commandLink Processa uma âncora HTML.
• h: outputLink Processa uma âncora HTML.
• h: panelGrid Renderiza uma Tabela HTML em forma de grade.
• h: mensagem Processa mensagem para um componente de UI JSF.
• h: mensagens Processa todas as mensagens para os Componentes de UI JSF.
• f: param Passar parâmetros para o componente de interface do usuário do JSF.
• f: attribute Passe o atributo para um componente de interface do usuário do
JSF.
• f: setPropertyActionListener Define o valor da propriedade de um bean
gerenciado.
Parâmetros com JSF
A tag f:param fornece as opções para passar parâmetros para um componente ou
passar parâmetros de requisição.
Ele funciona passando parâmetros pela URL ou também passando para componentes
e isso é uma coisa muito bacana e funcional.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Abaixo temos o exemplo de como passamos parâmetros e fazemos a captura dele do
lado do servidor.
E do lado do servidor pegamos o valor do action com o seguinte código.
Agora na variável action temos o valor passado como parametros para assim definir o
que processar do lado do servidor.
Conhecendo show case JSF e PrimeFaces
PrimeFaces é uma coleção de componentes de UI ricos para JavaServer Faces. Todos
os widgets são open source e gratuitos para uso sob licença Apache. O PrimeFaces é
desenvolvido pela PrimeTek Informatics, um fornecedor com anos de experiência no
desenvolvimento de soluções de UI de código aberto.
A forma mais correta e fácil de aprender a usar os componentes de um frameworks é
olhando a documentação e nessa parte o PrimeFaces é excelente ele possui um show
case onde tem o exemplo como ficará em seu sistema, tem o código fonte na página
XHTML e também o código do ManagedBean, para todos os componentes do
primefaces existe um exemplo bem práticos e fácil demonstrando a construção do
mesmo, para usar recursos mais avançados e específicos de cada componente é
comente baixar o PDF da documentação do PrimeFaces procurar pelo capítulo do
componente que existe uma tabela de todas as opções para cada um dos
componentes.
Vamos aprender um pouco como usar o show case do PrimeFaces.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Para acessar a área de exemplo basta ir para o link
https://www.primefaces.org/showcase/.
A esquerda existem todos os componentes disponíveis no frameworks e para cada
categoria existe uma lista de componentes mais sofisticados ou mais simples e casa
um tem o seu objetivo em solucionar um problema ou ser implementado no sistema
para uma solução.
Show case do AjaxCore: Um método java pode ser invocado em uma requisição ajax
usando a opção listener de p: ajax.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Então todos seguem o mesmo padrão onde em cima é como fica o componente e em
baixo a primeira parte sempre é o código JSF e a segunda parte o código Java do lado
no managedBean (Servidor).
Seguindo essa linha de pensamento na documentação fica superfácil criar qualquer
sistema em JSF e PrimeFaces.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Show case dos componentes Input:
A maior variedade está nessa parte onde possui a maior quantidade de componentes
para usar em todos os tipo de sistemas que podem ser pensados.
E assim você é livre pra escolher os componentes que solucionam o problema e
aplicar em seu projeto.
Código JSF na página XHTML:
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Código ManagedBean:
Datatable se torna super fácil com PrimeFaces
DataTable exibe dados em formato tabular.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
O segredo de um datatable é ter uma lista de objetos carregados no managedBean e
apontar ela no atributo value do componente dataTable.
Acima vimos como fica o JSF e abaixo vimos como fica o managedBean, e neste
possui um exemplo que carrega dados estaticos em uma classe Java a parte que em
nosso caso seria o banco de dados.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Abaixo nossa classe simulando o banco de dados.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Gráficos com PrimeFaces
Frameworks como o PrimeFaces tem a grande capacidade de transformar coisa
complicadas em simples e isso é ótimo para nós programadores porque podemos
focar na regra de negocio e em ter produtividade na entrega e na criação dos sistemas.
Vamos ver um exemplo de um grafico combinado.
A facilidade do JSF com PrimeFaces é incrível, abaixo conseguir criar um gráfico
apenas com uma linha na tela JSF e na próxima imagem veremos do lado do servidor
o carregamento de dados.
Especificamos o tipo que é bar e o model onde é carregado a lista de dados,
lembrando que para cada tipo de dados existe a estrutura correta da lista de objetos
para ser carregada.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Classes e objetos usados para criar a estrutura da lista para formar o gráfico são do
próprio PrimeFaces então manual e o showcase se tornam de suma importância para
o aprendizado.
Capturando erros com ExceptionHandler
Todos os que codificam aplicativos da Web Java EE precisam prestar atenção ao
tratamento de exceções. Quando um programa encontra um erro, os desenvolvedores
podem exibir mensagens amigáveis para os usuários finais, o que aumenta sua
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
confiança no aplicativo. Além disso, adicionando o tratamento adequado de exceções,
você pode solucionar problemas e depurar defeitos do aplicativo.
Desde a versão 2.0, a estrutura JavaServer Faces suporta um mecanismo de
tratamento de exceções para fornecer um local centralizado para lidar com exceções
em aplicativos JSF. Veja como você pode utilizá-lo para escrever aplicativos
profissionais.
Pra isso temos opções diferentes:
• Tratar exceções com Ajax.
• Tratar exceções sem Ajax
Como já sabemos quando dá uma exceção em uma requisição Ajax temos que
capturar isso na resposta e mostrar para o usuário e quando não é Ajax a página deve
ser recarrega para ser mostrada o erro.
ExceptionHandler com Ajax
Primeiramente precisamos ter um Dialog do PrimeFaces que irá abrir uma tela para o
usuário e dentro dele temos que desenvolver a rotina para a captação da mensagem de
erro.
E no botão como estamos utilizando Ajax e também não precisamos de nenhum
redirecionamento vamos usar o ActionListener e passamos no atributo ajax o valor
true do nosso botão e então teremos efeito em Ajax e sem redirecionar.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
E para testarmos a nossa rotina de captura de erros podemos fazer um método em
nosso managedBean que lança algum erro/exceção do Java e o PrimeFaces irá se
encarregar de mostrar o erro em nosso Dialog.
O resultado que vamos ter é um Dialog com a lista de erros.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
ExceptionHandler sem Ajax
A única diferença do que fizemos acima é passar no atributo do nosso botão o Ajax
para ser false, assim, o redirecionamento é feito e será exibido dentro do próprio
navegador a pilha de erro.
Assim a pilha de erro não sendo exibida dentro do Dialog e sim dentro do navegador
teremos um resultado abaixo.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Confirm Dialog
ConfirmDialog é integrado com o comportamento de confirmação e usado como um
substituto para o utilitário de confirmação de javascript.
A rotina mais normal em um sistema é pedir para o usuário se ele realmente quer
efetuar uma operação sim ou não.
Usando o PrimeFaces temos um opção bem legal que é p:confirm onde se o usuário
clicar em sim então o método do managedBean do lado do servidor será invocado,
caso contrário nada será feito.
Normalmente é feito em botões de excluir ou em rotinas mais importantes como
alterações de dados e exclusões importantes.
Teremos o seguinte feito, quando clicarmos no botão de excluir ou editar que assim
seja depende do que você quer fazer em seu sistema.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
As mensagens são customizadas e fáceis de escrever o que quisermos para melhorar o
sistema.
Então clicando em não nada será feito e clicando em sim será executado o nosso
metodo dentro actionListener do commandButton.
Confirm DialogGMap – Basic
Google Maps é um serviço de pesquisa e visualização de mapas e imagens de satélite
da Terra gratuito na web fornecido e desenvolvido pela empresa estadunidense
Google. Atualmente, o serviço disponibiliza mapas e rotas para qualquer ponto nos
Estados Unidos, Canadá, na União Europeia, Austrália e Brasil, entre outros.
Mas como implementar isso em nosso sistema? A resposta é fácil até demais, como já
sabemos a muitos anos lá em nossas aulas de geografia que as localizações são por
latitude e longitude, então, a forma mais simples de implantar isso em nosso sistema
é passando essas localizações para o componente do PrimeFaces.
Então teremos o seguinte resultado abaixo.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Barcode
O componente de código de barras gera vários tipos de códigos de barras nos
formatos PNG ou SVG. Os navegadores sem suporte a SVG recuam
automaticamente para o PNG.
Códigos de barrar são muito usados em quaisquer sistemas comercial onde não
precisa digitar e podem ser lidos com leitores. Parece complicado mas quando temos
um Frameworks que faz tudo por nós a única coisa que precisamos passar pra ele é o
valor do código de barras e o tipo a ser gerado e pronto está feito o código para ser
impresso e lido.
Na página JSF temos o seguinte código do Primefaces.
E o resultado em tela é o seguinte.
Aqui neste exemplo estamos passando o valor fixo mas para tornar isso dinâmico
basta trazer do banco de dados em um objeto controlado com o managedBean e
pronto temos os códigos de barras dinâmicos.
Chamadas de Ajax periódicas
Um recurso muito mas muito bacana mesmo e muito utilizado e executar rotinas em
determinado tempo em um sistema e é claro que o PrimeFaces iria nos surpreender
cada vez mais.
O p:poll faz chamadas Ajax com intervalos de tempo em nossos sistemas, então
vamos supor que queríamos mostrar no canto dos sistemas quantas mensagens não
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
lidas o usuário tem pra isso essa seria a solução para quem está criando projetos com
PrimeFaces e JSF.
Vou dar um exemplo bem simples que é incrementar um numero automaticamente do
lado do servidor e fazendo apenas isso sabemos que podemos processar qualquer
coisa por vai complexa que seja e retornar na tela o resultado.
Então em um exemplo simples na tela JSF usando o p:poll teríamos o código simples
abaixo.
Do lado do servidor no managedBean teríamos o seguinte código.
Growl do PrimeFaces
O p:growl é uma forma elegante de mostrar mensagens em um sistema para o
usuário.
Na página JSF ficaria o seguinte código.
Em nosso managedBean seria o seguinte código.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Download do manual do PrimeFaces
Atualmente no momento que estou escrevendo esse super e-book o PrimeFaces se
encontra na versão 6.2 para baixar o e-book completo passo a passo de todo os
componentes para criar aplicações acesse o link CLIQUE AQUI
Na página oficial selecione a versão do manual para baixar o PDF oficial.
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
Referências
https://www.primefaces.org/documentation/
https://www.primefaces.org/showcase/
https://www.tutorialspoint.com/jsf/
https://www.javatpoint.com/jsf-tutorial
CLIQUE AQUI – Conheça o curso Formação Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Desenvolvimento Java com
Jdbc
Jpa e Hibernate
Spring Data
Alex Fernando Egidio
Desenvolvedor Java Sênior
https://www.javaavancado.com
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Sumário
Introdução ao JDBC.........................................................................................................................4
Introdução ao SQL...........................................................................................................................4
Linguagem DDL..............................................................................................................................5
Linguagem DML.............................................................................................................................6
Criando banco de dados...................................................................................................................7
Criando tabela de dados...................................................................................................................7
Componentes JDBC.........................................................................................................................8
Classe de conexão com banco.........................................................................................................9
Interface PreparedStatement..........................................................................................................10
Por que usar o PreparedStatement?...............................................................................................10
A classe de modelo de dados.........................................................................................................10
Padrão DAO...................................................................................................................................11
Inserindo dados no banco de dados...............................................................................................12
Realizando consulta de todos os dados da tabela..........................................................................12
Realizando buscar por ID..............................................................................................................13
Realizando Update de dados..........................................................................................................14
Deletando registro no banco de dados...........................................................................................14
Considerações finais sobre o JDBC...............................................................................................15
O que é JPA?..................................................................................................................................16
História da Especificação JPA.......................................................................................................16
JPA 2.0 (Java Persistence API)......................................................................................................17
Configurando Maven com JPA......................................................................................................18
Arquivo de configuração do JPA...................................................................................................19
Classe de conexão do JPA..............................................................................................................20
Introdução ao EntityManager........................................................................................................20
DaoGeneric JPA.............................................................................................................................21
Anotação @Entity..........................................................................................................................21
Anotação @Id................................................................................................................................22
Anotação @OneToMany e @ManyToOne....................................................................................22
Anotação @OneToOne..................................................................................................................23
Anotação @ManyToMany.............................................................................................................23
Anotação @NaturalId....................................................................................................................25
Anotação @Table...........................................................................................................................25
Anotação @UniqueConstraint.......................................................................................................26
Anotação @Version.......................................................................................................................26
Anotação @Colum.........................................................................................................................27
Anotaçõe @GeneratedValue e @SequenceGenerator...................................................................27
Anotação @GeneratedValue..........................................................................................................28
Anotação @Transient....................................................................................................................28
Anotação @Lob.............................................................................................................................29
Retornando a primary key da entidade..........................................................................................29
Salvando com JPA (Persist)...........................................................................................................30
Save or Update com JPA (Merge)..................................................................................................30
Pesquisar um registro no banco de dados......................................................................................31
Deletando registros........................................................................................................................31
Trazendo lista de dados do banco de dados...................................................................................31
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Gravando objeto no banco com JPA..............................................................................................32
Consultando objetos no banco de dados........................................................................................32
Atualizando objetos no banco de dados.........................................................................................33
Deletando objetos no banco de dados............................................................................................33
Consultando lista de dados............................................................................................................34
Carregando uma lista condicional..................................................................................................34
Limitando máximo de resultados...................................................................................................35
Usando parâmetros dinâmicos.......................................................................................................36
Operações de média de uma coluna...............................................................................................36
Anotação @NamedQuery e @NamedQueries..............................................................................37
Chamando um query nomeada......................................................................................................37
JPA - API de critérios.....................................................................................................................38
Bean Validation..............................................................................................................................40
Hibernate Search............................................................................................................................41
Hibernate Envers............................................................................................................................42
Considerações finais sobre o JPA..................................................................................................42
Spring Data....................................................................................................................................43
Configuração do Maven e Spring Data..........................................................................................43
Configurando o Persistence para integrar com Spring..................................................................44
Configurando o arquivo Spring-Config.xml..................................................................................44
Ativando a auto configuração do Spring.......................................................................................44
Configurando a conexão com o banco de dados............................................................................45
Configurando o JPA integrando com o Spring e o Hibernate........................................................45
Controle Transacional e Repository...............................................................................................45
Interface CrudRepository...............................................................................................................46
Anotação @Repository..................................................................................................................47
Anotação @Transactional..............................................................................................................47
Anotação @Query.........................................................................................................................48
Anotação @Modifying..................................................................................................................48
Sobrescrevendo métodos de interface............................................................................................49
Junit com Spring Data....................................................................................................................49
Anotação @Autowired..................................................................................................................50
Teste unitário @Test......................................................................................................................51
Criando o teste de inserir...............................................................................................................52
Criando o teste de consulta............................................................................................................52
Criando o teste de consulta por lista..............................................................................................53
Criando o teste de update...............................................................................................................54
Criando o teste de delete................................................................................................................54
Consulta assíncrona.......................................................................................................................55
Usando Sort....................................................................................................................................55
Auditoria........................................................................................................................................56
Metadados de auditoria baseados em anotação.............................................................................57
Considerações finais sobre o Spring Data.....................................................................................57
Spring Web MVC..........................................................................................................................58
Spring RESTful..............................................................................................................................58
Spring Boot....................................................................................................................................60
Spring Batch..................................................................................................................................61
Spring Batch Architecture..............................................................................................................63
Conclusão.......................................................................................................................................64
Cursos para você ser profissional em programação.......................................................................64
Referências.....................................................................................................................................65
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Introdução ao JDBC
Java Database Connectivity ou JDBC é um conjunto de classes e interfaces (API)
escritas em Java que fazem o envio de instruções SQL para qualquer banco de
dados relacional;
• Api de baixo nível e base para api’s de alto nível;
• Amplia o que você pode fazer com Java;
• Possibilita o uso de bancos de dados já instalados;
Para cada banco de dados há um driver JDBC especifico que no Java é sempre
uma lib/jar que deve ser adicionando ao projeto de acordo com o banco que será
usado.
Introdução ao SQL
Structured Query Language, ou Linguagem de Consulta Estruturada ou SQL, é a
linguagem de pesquisa declarativa padrão para banco de dados relacional (base
de dados relacional).
Muitas das características originais do SQL foram inspiradas na álgebra relacional.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
O SQL foi desenvolvido originalmente no início dos anos 70 nos laboratórios da
IBM em San Jose, dentro do projeto System R, que tinha por objetivo demonstrar a
viabilidade da implementação do modelo relacional proposto por E. F. Codd.
Linguagem DDL
Linguagem de definição de dados (LDD ou DDL, do Inglês Data Definition
Language) é uma linguagem de computador usada para a definição de estruturas
de dados.
O termo foi inicialmente introduzido em relação ao modelo de banco de dados
Codasyl, onde o esquema de banco de dados era escrito em uma Linguagem de
Definição de Dados descrevendo os registros, campos e "conjuntos" que
constituíam o Modelo de dados do usuário.
Inicialmente referia-se a um subconjunto da SQL, mas hoje é usada em um sentido
genérico para referir-se a qualquer linguagem formal para descrição de estruturas
de dados ou informação, assim como esquemas.
Um exemplo é o CREATE DATA BASE ou então o CREATE TABLE e assim por
diante, sempre destinado a definir a estrutura do banco de dados.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Linguagem DML
Linguagem de Manipulação de Dados (ou DML, de Data Manipulation Language) é
uma família de linguagens de computador utilizada para a recuperação, inclusão,
remoção e modificação de informações em bancos de dados.
Pode ser procedural, que especifica como os dados devem ser obtidos do banco;
pode também ser declarativa (não procedural), em que os usuários não
necessitam especificar o caminho de acesso, isto é, como os dados serão obtidos.
O padrão SQL é não procedural. DMLs foram utilizadas inicialmente apenas por
programas de computador, porém (com o surgimento da SQL) também têm sido
utilizadas por pessoas.
Dentro desse contexto o mais importante são as clausulas SELECT, UPDATE,
DELETE e INSERT e a mais usada é SELECT que é usada para extrair dados do
banco de dados.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Criando banco de dados
Usando a linguagem SQL mais precisamente a DDL que é a linguagem de
definição de dados o primeiro passo é a criação do banco de dados.
Criando tabela de dados
Usando a linguagem SQL mais precisamente a DDL que é a linguagem de
definição de dados o segundo passo é a criação da tabela de dados.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Componentes JDBC
DriverManager: esta classe gerencia uma lista de drives de banco de
dados. Corresponde às solicitações de conexão do aplicativo Java com o driver de
banco de dados adequado usando o subprotocolo de comunicação. O primeiro
driver que reconhece um determinado subprotocolo no JDBC será usado para
estabelecer uma conexão com o banco de dados.
Driver: Essa interface lida com as comunicações com o servidor de banco de
dados. Você irá interagir diretamente com objetos Driver muito raramente. Em vez
disso, você usa objetos DriverManager, que gerencia objetos desse tipo. Ele
também abstrai os detalhes associados ao trabalho com objetos Driver.
Connection: Essa interface com todos os métodos para entrar em contato com um
banco de dados. O objeto de conexão representa o contexto de comunicação, ou
seja, toda a comunicação com o banco de dados é feita apenas por meio do objeto
de conexão.
Statement: Você usa objetos criados a partir dessa interface para enviar as
instruções SQL para o banco de dados. Algumas interfaces derivadas aceitam
parâmetros além de executar procedimentos armazenados.
ResultSet: Esses objetos armazenam dados recuperados de um banco de dados
depois que você executa uma consulta SQL usando objetos Statement. Ele age
como um iterador para permitir que você se mova através de seus dados.
SQLException: Esta classe manipula todos os erros que ocorrem em um
aplicativo de banco de dados.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Classe de conexão com banco
Sempre precisamos de uma classe que estabelece a conexão com o banco de
dados e quando falar de JDBC é usado uma classe Java com padrão Singleton
para conectar e oferecer apenas uma conexão ativa e funcional para nosso projeto
de sistemas.
Dentro desta mesma classe criamos o método responsável por executar a conexão
e retorna a mesma quando necessitamos.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Pra finalizar o padrão Singleton teremos sempre ao final um método estático que
retorna o objeto de conexão com o banco de dados.
Interface PreparedStatement
A interface PreparedStatement é uma subinterface do Statement. É usado para
executar consultas parametrizadas.
Por que usar o PreparedStatement?
Melhora o desempenho : O desempenho do aplicativo será mais rápido se você
usar a interface PreparedStatement porque a consulta é compilada apenas uma
vez.
A classe de modelo de dados
Como Java é orientado a objetos nada mais correto do que ter um objeto que
representa nosso negócio e também representa a tabela no banco de dados e para
isso já podemos seguir um padrão mais básico e fácil que existe no
desenvolvimento de sistemas que é criar uma classe que tráfega os dados em
todas as camadas do sistema até chegar ao banco de dados e do banco para as
camadas do sistema, então, em uma tabela que possuí id, nome e e-mail a classe
de modelo ficaria como a imagem abaixo:
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Padrão DAO
Objeto de acesso a dados (ou simplesmente DAO, acrônimo de Data Access
Object), é um padrão para persistência de dados que permite separar regras de
negócio das regras de acesso a banco de dados.
Neste caso que vou exemplificar para nosso estudo de caso. Dentro do DAO já
definimos o objeto Connection e dentro do construtor já chamamos a nossa classe
que faz a conexão e retorna a conexão pronta para efetuar as operações de
CRUD.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Inserindo dados no banco de dados
Neste passo já vamos aprender como fazer o método salvar em nossa estrutura
DAO. O salvar já recebe o objeto com os dados, escrevemos o SQL e os
parâmetros são representados pelas interrogações (?, ?) e são setados na mesma
ordem que são escritos na String do SQL;
Realizando consulta de todos os dados da tabela
Depois que criamos a rotina de insert que é a gravação de dados no banco de
dados já podemos testar e fazer outra rotina muito importante que é a consulta ao
banco de dados.
Para isso usamos o a instrução d DML que é o select, com ela podemos
estabelecer a consulta a todos os registros da tabela ou apenas a alguns valores
específicos de algumas colunas e o mais importante é que precisamos de um
objeto que nos retorna esse tipo de consulta e o JDBC tem o ResultSet que é o
responsável por armazenar os dados trazidos do banco de dados e com isso
usando a API Jdbc com Java podemos recuperar os dados facilmente.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Realizando buscar por ID
A busca por ID especifico no banco de dados é superfácil, anteriormente criamos a
consulta onde carregamos toda a lista de dados de uma única tabela e agora
vamos aprender a carregar apenas um objeto passando por parâmetro o
identificador de primary key.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Realizando Update de dados
Um dos principais pontos de um sistema é a atualização de dados que estão no
banco de dados e que já foram cadastrados em outras etapas. Isso é possível
fazer usando o DML com a cláusula update onde especificamos os parâmetros que
serão alterados e informamos alguma condição para filtras dados apara serem
alterados ou simplesmente alter toda a tabela de dados.
Deletando registro no banco de dados
Um dos principais pontos de um sistema é a remoção de dados que estão no
banco de dados e que já foram cadastrados em outras etapas. Isso é possível
fazer usando o DML com a cláusula delete onde especificamos sempre o ID que
identifica a chave única do registro ou uma determina condição que pode remover
vários registro de uma vez.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Considerações finais sobre o JDBC
Usar apenas JDBC hoje em dia é inviável e completamente improdutivo para a
equipe e gera muitos bugs e manutenção para a equipe, mas, ainda assim, é muito
importante para aprender a usar os frameworks que usam todo esse conceito por
baixo dos panos e quando se fala de processamento rápido onde cada segundo é
importante o SQL e JDBC puro ainda é o que temos de mais rápido
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
O que é JPA?
JPA é um framework leve, baseado em POJOS (Plain Old Java Objects) para
persistir objetos Java. A Java Persistence API, diferente do que muitos imaginam,
não é apenas um framework para Mapeamento Objeto-Relacional (ORM - ObjectRelational Mapping), ela também oferece diversas funcionalidades essenciais em
qualquer aplicação corporativa.
Atualmente temos que praticamente todas as aplicações de grande porte utilizam
JPA para persistir objetos Java.
JPA provê diversas funcionalidades para os programadores, como será mais
detalhadamente visto nas próximas seções. Inicialmente será visto a história por
trás da JPA, a qual passou por algumas versões até chegar na sua versão atual.
História da Especificação JPA
Após diversos anos de reclamações sobre a complexidade na construção de
aplicações com Java, a especificação Java EE 5 teve como principal objetivo a
facilidade para desenvolver aplicações JEE 5. O EJB 3 foi o grande percursor para
essa mudança fazendo os Enterprise JavaBeans mais fáceis e mais produtivos de
usar.
No caso dos Session Beans e Message-Driven Beans, a solução para questões de
usabilidade foram alcançadas simplesmente removendo alguns dos mais onerosos
requisitos de implementação e permitindo que os componentes sejam como Plain
Java Objects ou POJOS.
Já os Entity Beans eram um problema muito mais sério. A solução foi começar do
zero. Deixou-se os Entity Beans sozinhos e introduziu-se um novo modelo de
persistência.
A versão atual da JPA nasceu através das necessidades dos profissionais da área
e das soluções proprietárias que já existiam para resolver os problemas com
persistência. Com a ajuda dos desenvolvedores e de profissionais experientes que
criaram outras ferramentas de persistência, chegou a uma versão muito melhor
que é a que os desenvolvedores Java conhecem atualmente.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Dessa forma os líderes das soluções de mapeamento objetos-relacionais deram
um passo adiante e padronizaram também os seus produtos. Hibernate e TopLink
foram os primeiros a firmar com os fornecedores EJB.
O resultado final da especificação EJB finalizou com três documentos separados,
sendo que o terceiro era o Java Persistence API. Essa especificação descrevia o
modelo de persistência em ambos os ambientes Java SE e Java EE.
JPA 2.0 (Java Persistence API)
No momento em que a primeira versão do JPA foi iniciada, outros modelos de
persistência ORM já haviam evoluído. Mesmo assim muitas características foram
adicionadas nesta versão e outras foram deixadas para uma próxima versão.
A versão JPA 2.0 incluiu um grande número de características que não estavam na
primeira versão, especialmente as mais requisitadas pelos usuários, entre elas a
capacidade adicional de mapeamento, expansões para a Java Persistence Query
Language (JPQL), a API Criteria para criação de consultas dinâmicas, entre outras
características.
Entre as principais inclusões na JPA destacam-se:
POJOS Persistentes: Talvez o aspecto mais importante da JPA seja o fato que os
objetos são POJOs (Plain Old Java Object ou Velho e Simples Objeto Java),
significando que os objetos possuem design simples que não dependem da
herança de interfaces ou classes de frameworks externos.
Qualquer objeto com um construtor default pode ser feito persistente sem
nenhuma alteração numa linha de código. Mapeamento Objeto-Relacional com
JPA é inteiramente dirigido a metadados. Isto pode ser feito através de anotações
no código ou através de um XML definido externamente.
Consultas em Objetos: As consultas podem ser realizadas através da Java
Persistence Query Language (JPQL), uma linguagem de consulta que é derivada
do EJB QL e transformada depois para SQL. As consultas usam um esquema
abstraído que é baseado no modelo de entidade como oposto às colunas na qual a
entidade é armazenada.
Configurações simples: Existe um grande número de características de
persistência que a especificação oferece, todas são configuráveis através de
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
anotações, XML ou uma combinação das duas. Anotações são simples de usar,
convenientes para escrever e fácil de ler. Além disso, JPA oferece diversos valores
defaults, portanto para já sair usando JPA é simples, bastando algumas anotações.
Integração e Teste: Atualmente as aplicações normalmente rodam num Servidor de
aplicação, sendo um padrão do mercado hoje. Testes em servidores de aplicação
são um grande desafio e normalmente impraticáveis.
Efetuar teste de unidade e teste caixa branca em servidores de aplicação não é
uma tarefa tão trivial. Porém, isto é resolvido com uma API que trabalha fora do
servidor de aplicação.
Isto permite que a JPA possa ser utilizada sem a existência de um servidor de
aplicação. Dessa forma, testes unitários podem ser executados mais facilmente.
Configurando Maven com JPA
Abaixo estão as dependencias para serem baixadas apenas do hibernate/jpa,
adicionando ela serão baixar uma lista enorme de bibliotecas que são obrigatórias
para o uso do frameworks.
Abaixo podemos ver a lista enorme de bibliotecas que são baixadas quando
adicionamos as tags xml no pom.xml do Maven, está parte pode ser vista no
projeto.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Arquivo de configuração do JPA
Quando usamos JDBC tudo era configurado direto em uma classe Java criada do
zero, usando JPA isso é feito de forma mais organizada usando um arquivo de xml
onde são configurados os mesmos parâmetros como url do banco de dados,
usuário do banco, senha do banco de dados e ainda temos muitos outros recursos
como permitir a geração automática das tabelas no banco de dados.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Classe de conexão do JPA
Agora como temos todos os dados escritos no arquivo de xml de configuração
precisamos apenas de uma classe para dar o start inicial na conexão do banco de
dados, sendo um frameworks extremamente completo o JPA nos dá uma classe
que faz exatamente a leitura do arquivo de configuração e já realiza todas as
funções configuradas no arquivos e já disponibiliza um objeto
EntityManagerFactory que é o responsável por ter os métodos de operações com o
banco de dados.
Introdução ao EntityManager
Na nova Java Persistence Specification, o EntityManager é o serviço central para
todas as ações de persistência. Entidades são objetos de Java claros que são
alocados como qualquer outro objeto Java. O EntityManager administra o O/R
que o mapea entre uma classe de entidade e uma fonte de dados subjacente.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
DaoGeneric JPA
Quando trabalhamos com JPA a escrita de SQL é quase zero, o frameworks além
de ter sua própria linguagem que é o HQL ainda possui inúmeros métodos que são
comuns a todo sistema que é criado e então nós programadores apenas
precisamos saber qual método invocar e com apenas uma chamada fazer muito
mesmo no banco de dados, ao invés de escrever linhas e mais linhas de SQL puro
apenas chamamos no caso do JPA o método PERSIST que os dados são
gravados corretamente no banco de dados, o melhor de tudo que o DAO genérico
agora fica muito mais simples e fácil de entender. Ao invés da conexão direta nós
invocamos o EntityManager dentro do DAO.
Anotação @Entity
A anotação @Entity é utilizada para informar que uma classe também é uma
entidade. A partir disso, a JPA estabelecerá a ligação entre a entidade e uma tabela
de mesmo nome no banco de dados, onde os dados de objetos desse tipo poderão
ser persistidos.
Uma entidade representa, na Orientação a Objetos, uma tabela do banco de
dados, e cada instância dessa entidade representa uma linha dessa tabela.
Caso a tabela possua um nome diferente, podemos estabelecer esse mapeamento
com a anotação @Table, a qual será explorada em outra documentação.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @Id
A anotação @Id é utilizada para informar ao JPA qual campo/atributo de uma
entidade estará relacionado à chave primária da respectiva tabela no banco de
dados. Essa é uma anotação obrigatória e um erro será gerado em tempo de
execução caso ela não esteja presente.
Anotação @OneToMany e @ManyToOne
O relacionamento OneToMany é bem usado, e são poucas vezes que de fato não
precisamos te-lo, então é aquele lance se não precisou até hoje, espere mais um
pouco que essa necessidade vai nascer.
Vamos tirar a vantagem dos annotations e veremos @OneToMany e
@ManyToOne ao invés dos .hbm. Como exemplo há vários cenários para
exemplificar este tipo de relacionamento, tais como: um time de futebol tem vários
jogadores, uma infra-estrutura tem vários servidores, porém um jogador só pode
jogar em um time(ou não depende da regra de negócio, aqui está o pulo do gato),
e um servidor está em uma infra-estrutura.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @OneToOne
A anotação One-to-One é utilizada para associar duas entidades onde uma não é
componente da outra, ao contrário da definição acima.
Numa associação One-to-One também podemos ter um relacionamento
bidirecional. Nesse caso, um dos lados precisará ser o dono do relacionamento e
ser responsável por atualizar uma coluna com uma chave estrangeira.
Anotação @ManyToMany
Define uma associação de muitos valores com multiplicidade de muitos para
muitos.
Toda associação muitos-para-muitos tem dois lados, o lado proprietário e o lado
não-proprietário ou inverso. A tabela de junção é especificada no lado proprietário.
Se a associação for bidirecional, qualquer um dos lados pode ser designado como
o lado proprietário. Se o relacionamento for bidirecional, o lado não proprietário
deverá usar o mappedByelemento da ManyToMany anotação para especificar o
campo ou propriedade de relacionamento do lado proprietário.
A tabela de junção para o relacionamento, se não for padronizada, é especificada
no lado proprietário.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
A ManyToMany anotação pode ser usada em uma classe incorporável contida em
uma classe de entidade para especificar um relacionamento com uma coleção de
entidades. Se o relacionamento for bidirecional e a entidade que contém a classe
incorporável for o proprietário do relacionamento, o lado não proprietário deverá
usar o mappedBy elemento da ManyToMany anotação para especificar o campo
ou a propriedade de relacionamento da classe incorporável.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @NaturalId
Embora não seja usada como propriedade do identificador, algumas propriedades
(do grupo) representam o identificador natural de uma entidade. Isso é
especialmente verdadeiro quando o esquema usa a abordagem recomendada de
uso de chave primária substituta, mesmo que exista uma chave de negócios
natural.
O Hibernate permite mapear essas propriedades naturais e reutilizá-las em uma
consulta Criteria. O identificador natural é composto de todas as propriedades
marcadas como @NaturalId.
Para exemplificar melhor podemos ter a entidade usuario ou pessoa e além do ID
que é primary key podemos ter um chave natural por exemplo o CPF.
Anotação @Table
@Tabela é definida no nível da turma; Ele permite que você defina os nomes de
tabelas, catálogos e esquemas para o mapeamento de entidades. Se nenhuma
@Table for definida, os valores padrão serão usados: o nome de classe não
qualificado da entidade.
O elemento @Table contém um esquema e atributos de catálogo, se precisarem
ser definidos. Você também pode definir restrições exclusivas para a tabela usando
a anotação @UniqueConstraint em conjunto com @Table.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @UniqueConstraint
É possível e normal termos restrições em um banco de dados como por exemplo
não poder cadastrar a mesma pessoa com login e senha igual, bem sabemos que
cadastrar com o mesmo login já é um bloqueio normal e mais comum de se fazer
em um banco de dados e também é super importante não deixar gravar com a
mesma senha também e isso podemos fazer de um forma bem simples com
anotações no JPA usando a anotação @UniqueConstraint.
Anotação @Version
Você pode adicionar capacidade de bloqueio otimista a uma entidade usando a
anotação @Version.
A propriedade version será mapeada para a coluna OPTLOCK e o gerenciador de
entidades a utilizará para detectar atualizações conflitantes (evitando atualizações
perdidas que você poderia ver com a estratégia last-commit-wins).
A coluna da versão pode ser um numérico (a solução recomendada) ou um registro
de data e hora. O Hibernate suporta qualquer tipo de tipo desde que você defina e
implemente o UserVersionType apropriado.
O aplicativo não deve alterar o número da versão configurado pelo Hibernate de
qualquer forma. Para aumentar artificialmente o número da versão, verifique na
documentação de referência do Hibernate Entity Manager
LockModeType.OPTIMISTIC_FORCE_INCREMENT ou
LockModeType.PESSIMISTIC_FORCE_INCREMENT.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @Colum
É usado para especificar a coluna mapeada para uma propriedade ou campo
persistente.
Se nenhuma Column anotação for especificada, os valores padrão serão
aplicados.
As colunas usadas para um mapeamento de propriedades podem ser definidas
usando a anotação @Column. Use-o para substituir os valores padrão. Você pode
usar essa anotação no nível da propriedade para propriedades que são.
Essa anotação possibilita varios recursos importantes:
• name : nome da coluna diferente do atributo
• unique : define se o valor é unico
• nullable: define se posse ou não ser obrigatorios
• insertable: se a coluna será ou não parte da instrução insert
• updatable: se a coluna será ou não parte da instrução de atualização
• columnDefinition: define o tipo da coluna no banco da dos.
• table :define a tabela de destino (tabela primária padrão)
• length: comprimento da coluna
• precision: precisão decimal da coluna
• scale: coluna decimal da coluna se for útil
Vendo todas as opções que temos para as colunas podemos fazer e demonstar
uma regra bem bacana, usando a coluna de cpf como exempo podemos definir as
regras que o cpf é um atributo natural e que sua coluna do banco tem um nome
diferente do atributo e o campo será único no banco de dados e depois de gravado
não poderá ser modificado.
Anotaçõe @GeneratedValue e @SequenceGenerator
O JPA define cinco tipos de estratégias de geração de identificadores:
• AUTO - coluna, sequência ou tabela de identidade, dependendo do banco de
dados subjacente
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
• TABELA - tabela segurando o id
• IDENTIDADE - coluna de identidade
• SEQUÊNCIA – sequência cópia de identidade - a identidade é copiada de
outra entidade
Então criando a sequencia e dando nome a ela nós podemos definir que o ID ou
sendo a primary key usara esse nosso sequenciador.
Anotação @GeneratedValue
A anotação @GeneratedValue é utilizada para informar que a geração do valor do
identificador único da entidade será gerenciada pelo provedor de persistência.
Essa anotação deve ser adicionada logo após a anotação @Id. Quando não
anotamos o campo com essa opção, significa que a responsabilidade de gerar e
gerenciar as chaves primárias será da aplicação, em outras palavras, do nosso
código, como vemos no exemplo a seguir:
Anotação @Transient
Em muito casos precisamos carregar um valor apenas em tempo de execução até
terminar um determinado processo e esse valor não deve ser gravado no banco de
dados, o JPA possui a anotação @Transient que não torna o atributo da entidade
persistente.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @Lob
@Lob indica que a propriedade deve ser mantida em um Blob ou Clob,
dependendo do tipo de propriedade: java.sql.Clob, Character [], char [] e
java.lang.String serão persistidos em um Clob. java.sql.Blob, Byte [], byte [] e tipo
serializável serão persistidos em um Blob.
Esse tipo de campo normalmente é usado para gravar imagem, arquivos como pdf
e textos enormes.
Retornando a primary key da entidade
O próprio JPA possui um método dentro do EntityManagerFactory que é
responsável por retornar o valor da primary key da entidade, como sabemos esse
valor se encontra no atributos anotado com @ID e isso é util para criar rotinas
genéricas dentro do nosso sistema. Abaixo temos o código onde pode ser passado
a entidade e é retornado a PK da entidade.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Salvando com JPA (Persist)
Usando JPA toda aquela complexidade se ficar escrevendo SQL na mão e tendo
que a todo momento ficar adicionando novos atributos e gerando manutenção na
parte de persistencia tendo que ir manualmente e adicionar mais SQL a todo
momento, isso não existe com JPA, toda essa complexidade é abstraida e para
salvar basta chamar o método PERSIST.
Save or Update com JPA (Merge)
Bem traduzindo ao pé da letra o que acontece é que é muito a gente precisar
salvar os dados no banco de dados e consulta pra poder ter o estado persistente
do objeto e também para poder obter a chave única que foi gerada, estamos
falando da PK ou primary key e como um frameworks que se preze deve facilitar
nosso trabalho o JPA tem um método chamado de MERGE, ele atualiza dados
existentes ou então insere caso seja um novo objeto que está sendo inserido no
banco de dados e o melhor de tudo ele retorna o objeto pra nós igual está no
banco de dados.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Pesquisar um registro no banco de dados
Para realizar a pesquisa o JPA também tem um método pronto e nós apenas
precisamos passar a classe pra ele saber qual tabela buscar no banco e o ID do
objeto que no caso é o valor da chave única do registro que precisamos trazer.
Deletando registros
Para deletar registro a forma mais prática para evitar problemas de objetos em
memória é fazer o JPA executar um SQL de delete, mas antes disso precisamos
sabe o ID do objeto que desejamos remover, podemos passar direto como
parâmetro ou então fazer de forma bem genérica igual eu criei no método abaixo.
Trazendo lista de dados do banco de dados
Para recuperar uma lista de dados e registros do banco de dados precisamos
saber classe queremos carregar para que o JPA saiba qual tabela no banco de
dados buscar e assim montamos a nossa query usando o createQuery e logo após
a montagem dela pedimos o retorno em forma de lista de obejtos chamando o
método getResultList.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Gravando objeto no banco com JPA
Depois que temos toda a parte de persistência criada, JPA configurado, entidades
criadas e mapeadas e o DAO genérico criado e funcionando corretamente. Agora é
a hora de comer a gravar dados. Primeiramente precisamos chamar nosso DAO
logo em seguida instanciar um objeto e setar os dados do seu atributo e pra
finalizar gravar no banco de dados.
Consultando objetos no banco de dados
Para consultar algum registro especifico precisamos apenas do ID ou sendo a PK
do registro no banco de dados e com isso passando para o método de pesquisa o
objeto é retornado.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Atualizando objetos no banco de dados
Para atualizar algum registro especifico precisamos apenas do ID ou sendo a PK
do registro no banco de dados e com isso passando para o método de pesquisa o
objeto é retornado. Após o retorno a gente somente seta os valores dos novos
atributos e invocamos o metodo de MERGE onde ele irá atualizar os dados no
banco de dados e retornar o objeto em seu novo estado persistente.
Deletando objetos no banco de dados
Para deletar algum registro específico precisamos apenas do ID ou sendo a PK do
registro no banco de dados e com isso passando para o método de pesquisa o
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
objeto é retornado. Após o retorno passamos nosso objeto para nosso método que
faz o delete/remoção desse registro na base de dados.
Consultando lista de dados
Já temos construído a estrutura persistencia e agora queremos trazer uma lista de
dados e imprimir no console para termos a certeza que nosso método no listar no
DAO está correto.
Carregando uma lista condicional
A linguagem HQL nada mais é do que um SQL Orientado a Objetos, quando
estamos dentro do banco de dados nós pensamos em tabelas e suas relações e
quando estamos escrevendo para o JPA nós pensamos em objetos.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
No método que estou criando a lista é trazida do banco de dados quando os dados
satisfazem a pesquisa e sua condição, para exemplificar estou passando o meu
nome dentro do HQL dizendo para retornar apenas os dados onde o nome seja
exatamente igual a ‘Egidio’.
Limitando máximo de resultados
Vamos supor que tenhamos a seguinte regra de negócio: Trazer apenas a 5
primeira pessoas ordenadas por id ou que foram cadastradas primeiro, ou melhor
ainda trazer a 5 pessoas que foram cadastradas inicialmente, usando o
createQuery e após a instrução setarmos o setMaxResults(5) estamos dizendo
que nossa consulta ao banco somente irá trazer os 5 primeiro e a ordenação eu
coloquei no próprio HQL.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Usando parâmetros dinâmicos
O HQL possuí uma sintaxe de passagem de parâmetros dinâmicas isso facilita
muito a criação de métodos dinâmicos em nosso sistema em nosso caso estou
passando dois parâmetros onde pode corresponder ao nome OU ao sobrenome
com isso será retornado dados quando tiver registros com o nome ou com o
sobrenome passados como parâmetros.
Operações de média de uma coluna
Operações matemáticas são realizadas facilmente usando SQL e podemos usar
esse poder junto com o JPA e unir os dois para termos um resultado final por
exemplo média da idades das pessoas cadastradas, no exemplo abaixo fazemos
exatamente isso, devemos perceber que o resultado vai ser um número e então
pra isso no final usamos o getSingleResult para obter o resultado númerico.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @NamedQuery e @NamedQueries
Uma consulta nomeada é uma consulta definida estaticamente com uma string de
consulta imutável predefinida. O uso de consultas nomeadas em vez de consultas
dinâmicas pode melhorar a organização do código separando as cadeias de
consulta JPQL do código Java. Ele também reforça o uso de parâmetros de
consulta em vez de embutir literais dinamicamente na cadeia de consulta e resulta
em consultas mais eficientes.
A anotação @NamedQuery contém quatro elementos - dois dos quais são
obrigatórios e dois são opcionais. Os dois elementos
obrigatórios, nome e consulta, definem o nome da consulta e a própria string de
consulta e são demonstrados acima. Os dois elementos
opcionais, LockMode e dicas , fornecer substituição estática para
os setLockMode e setHint métodos.
Anexar várias consultas nomeadas à mesma classe de entidade requer envolvêlas em uma anotação @NamedQueries
Chamando um query nomeada
Anteriormente colocar as queryes nomeadas e anotadas em cima da nossa classe
pesistente e agora é a hora de aprender como invocar essa query e executar ela.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Para isso usaremos o método createNamedQuery passando o nome da query e
apenas mandamos executar e processar o retorno.
Caso a query tenha parâmetros isso não muda nada no que já aprendemos,
apenas chamamos a query pelo nome e passamos os parâmetros.
JPA - API de critérios
A API Criteria é uma API predefinida usada para definir consultas para entidades. É
a maneira alternativa de definir uma consulta JPQL. Essas consultas são seguras,
portáteis e fáceis de modificar, alterando a sintaxe.
Semelhante ao JPQL segue esquema abstrato (fácil de editar esquema) e objetos
incorporados. A API de metadados é mesclada com a API de critérios para modelar
entidades persistentes para consultas de critérios.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
A principal vantagem da API de critérios é que os erros podem ser detectados mais
cedo durante o tempo de compilação. Consultas JPQL baseadas em strings e
consultas baseadas em critérios JPA são iguais em desempenho e eficiência.
A API Criteria e o JPQL estão intimamente relacionados e têm permissão para
projetar usando operadores semelhantes em suas consultas.
Ele segue o pacote javax.persistence.criteria para projetar uma consulta. A
estrutura de consulta significa a consulta de critérios de sintaxe.
A consulta de critérios simples a seguir retorna todas as instâncias da classe de
entidade na fonte de dados.
A consulta demonstra as etapas básicas para criar um critério.
• EntityManager instância é usada para criar um objeto CriteriaBuilder .
• A instância CriteriaQuery é usada para criar um objeto de consulta. Os
atributos desse objeto de consulta serão modificados com os detalhes da
consulta.
• O método CriteriaQuery.from é chamado para definir a raiz da consulta.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
• CriteriaQuery.select é chamado para definir o tipo de lista de resultados.
• A instância TypedQuery <T> é usada para preparar uma consulta para
execução e especificar o tipo do resultado da consulta.
• Método getResultList no objeto TypedQuery <T> para executar uma
consulta. Esta consulta retorna uma coleção de entidades, o resultado é
armazenado em uma lista.
Bean Validation
O Bean Validation padroniza como definir e declarar restrições de nível de modelo
de domínio. Você pode, por exemplo, expressar que uma propriedade nunca deve
ser nula, que o saldo da conta deve ser estritamente positivo, etc.
Essas restrições de modelo de domínio são declaradas no próprio bean anotando
suas propriedades. O Bean Validation pode então lê-los e verificar se há violações
de restrição. O mecanismo de validação pode ser executado em diferentes
camadas em seu aplicativo sem ter que duplicar nenhuma dessas regras (camada
de apresentação, camada de acesso a dados). Seguindo o princípio DRY, Bean
Validation e sua implementação de referência, o Hibernate Validator foi
desenvolvido para essa finalidade.
A integração entre o Hibernate e o Bean Validation funciona em dois níveis.
Primeiro, é capaz de verificar instâncias na memória de uma classe para violações
de restrição. Segundo, ele pode aplicar as restrições ao metamodelo do Hibernate
e incorporá-las ao esquema do banco de dados gerado.
Cada anotação de restrição é associada a uma implementação de validador
responsável por verificar a restrição na instância da entidade. Um validador
também pode (opcionalmente) aplicar a restrição ao metamodelo do Hibernate,
permitindo que o Hibernate gere DDL que expressa a restrição. Com o ouvinte de
eventos apropriado, você pode executar a operação de verificação em inserções,
atualizações e exclusões feitas pelo Hibernate.
Ao verificar instâncias em tempo de execução, o Hibernate Validator retorna
informações sobre violações de restrições em um conjunto de ConstraintViolations.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Entre outras informações, o ConstraintViolation contém uma mensagem de
descrição de erro que pode incorporar o valor de parâmetro do pacote com a
anotação (por exemplo, limite de tamanho), e seqüências de mensagens que
podem ser externalizadas para um ResourceBundle.
Hibernate Search
Mecanismos de pesquisa de texto completo, como o Apache Lucene ™, são uma
tecnologia muito poderosa para fornecer consultas gratuitas de texto / eficiência
aos aplicativos.
Se sofre várias incompatibilidades ao lidar com um modelo de domínio de objeto
(mantendo o índice atualizado, incompatibilidade entre a estrutura de índice e o
modelo de domínio, consultando incompatibilidade ...) .
Hibernate Search indexa seu modelo de domínio graças a algumas anotações,
cuida de a sincronização de banco de dados / índice e traz de volta objetos
gerenciados regulares a partir de consultas de texto livre.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Hibernate Envers
O projeto Envers visa permitir uma auditoria fácil de classes persistentes. Tudo o
que você precisa fazer é anotar sua classe persistente ou algumas de suas
propriedades, que você deseja auditar, com @Audited. Para cada entidade
auditada, será criada uma tabela que conterá o histórico de alterações feitas na
entidade. Você pode recuperar e consultar dados históricos sem muito esforço.
Similarmente ao Subversion, a biblioteca tem um conceito de revisões.
Basicamente, uma transação é uma revisão (a menos que a transação não
modifique nenhuma entidade auditada). Como as revisões são globais, com um
número de revisão, você pode consultar várias entidades nessa revisão,
recuperando uma visão (parcial) do banco de dados nessa revisão. Você pode
encontrar um número de revisão com uma data e, ao contrário, você pode obter a
data em que uma revisão foi confirmada.
A biblioteca funciona com o Hibernate e requer anotações do Hibernate ou
gerenciador de entidades. Para que a auditoria funcione corretamente, as
entidades devem ter identificadores exclusivos imutáveis (chaves primárias). Você
pode usar o Envers onde quer que o Hibernate funcione: independente, dentro do
JBoss AS, com o JBoss Seam ou Spring.
Considerações finais sobre o JPA
O JPA é o frameworks mais usado no mundo quando se fala de persistência de
dados em Java, vimos como é poderoso e quanto facilita nosso trabalho não
precisando escrever tantas linha de código e ficar atento a tantos detalhes porque
usando um frameworks bugs, erro e manutenção diminuem muito mesmo em um
sistema.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Spring Data
O Spring Data JPA é um framework que nasceu para facilitar a criação dos nossos
repositórios.
Ele faz isso nos liberando de ter que implementar as interfaces referentes aos
nossos repositórios (ou DAOs), e também já deixando pré-implementado algumas
funcionalidades como, por exemplo, de ordenação das consultas e de paginação
de registros.
Ele (o Spring Data JPA) é, na verdade, um projeto dentro de um outro maior que é
o Spring Data. O Spring Data tem por objetivo facilitar nosso trabalho com
persistência de dados de uma forma geral. E além do Spring Data JPA, ele possui
vários outros projetos:
Configuração do Maven e Spring Data
Antes de tudo precisamos adicionar as lib/jar ao nosso projeto e para não
precisarmos passar o dia inteiro baixando na internet um a um usaremos o Maven
para baixar de uma vez tudo pra gente, então abaixo está as configurações do
pom.xml.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Configurando o Persistence para integrar com Spring
Agora integrando com Spring Frameworks nós apenas vamos configurar o nome
para o persistence-unit do JPA para que seja possível ativar os recursos em nosso
projeto.
A única declaração que teremos que manter nesse arquivo é a declaração para as
entidades persistentes.
Configurando o arquivo Spring-Config.xml
Esse arquivo em formato XML é lido pelo Spring quando o projeto é iniciado e suas
configurações adicionadas ao contexto do sistemas rodando no servidor. Neste
arquivo vamos configurar nosso repositórios, nossa injeção de dependência,
nossas configurações com o banco de dados e ativar a integração com JPA +
Hibernate + Spring.
Ativando a auto configuração do Spring
Nesta parte iremos falar para o Spring fazer as configurações lendo as anotações
em nossas classes Java.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Configurando a conexão com o banco de dados
Neste parte iremos configurar a conexão com nosso banco de dados, é igual
configurar com jdbc porém aqui quem vai cuidar dos processos mais complexos é
o Spring.
Configurando o JPA integrando com o Spring e o Hibernate
Nesta parte vamos configurar a conexão criada com DataSource a ligar com o JPA
do Spring Frameworks. Neste ponto vamos configurar nosso persistence unit e
também onde são configurados as propriedades para o hibernate
Controle Transacional e Repository
Neste momento estamos ativando a parte de controle transacional para o Spring
controlar as transações/operações do nosso sistemas com o banco de dados e
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
também a configuração de nossos repositoryes que serão usados para escrever
nossos métodos de operações de persistência.
Interface CrudRepository
A interface central na abstração do repositório Spring Data
é Repository(provavelmente não é uma grande surpresa).
Leva a classe de domínio para gerenciar, bem como o tipo de id da classe de
domínio como argumentos de tipo. Essa interface age principalmente como uma
interface de marcação para capturar os tipos com os quais trabalhar e para ajudálo a descobrir as interfaces que a estendem.
O CrudRepository fornece funcionalidade CRUD sofisticada para a classe de
entidade que está sendo gerenciada.
Normalmente, a sua interface de repositório vai estender Repository,
CrudRepository ou PagingAndSortingRepository.
Alternativamente, se você não deseja estender interfaces Spring Data, você
também pode anotar sua interface de repositório com @RepositoryDefinition.
Estendendo CrudRepositoryexpõe um conjunto completo de métodos para
manipular suas entidades.
Se você preferir ser seletivo sobre os métodos que estão sendo expostos, basta
copiar os que você deseja expor CrudRepositorypara o seu repositório de domínio.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Anotação @Repository
@Repository anota classes na camada de persistência, que atuará como um
repositório de banco de dados, toda camada do sistema que possui, classes
normal ou mesmo interfaces anotadas com @Repository identifica que são
responsáveis por processos no banco de dados e a chamada cama de
persistência.
Quando se trabalha com Spring Data usamos a interface CrudRepository que nos
dispões de todo o poder de persistencia com métodos prontos e fáceis de usar e
também torna super fácil a implementação de novas queryes para nosso sistemas.
Anotação @Transactional
Além da abordagem declarativa baseada em XML para configuração de transação,
você pode usar uma abordagem baseada em anotação.
Declarar semântica de transação diretamente no código-fonte Java coloca as
declarações muito mais próximas do código afetado.
Não há muito perigo de acoplamento indevido, porque o código que se destina a
ser usado transacionalmente é quase sempre implantado dessa maneira de
qualquer maneira.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
A facilidade de uso proporcionada pelo uso da @Transactional anotação é melhor
ilustrada com um exemplo, que é explicado no texto a seguir. Considere a seguinte
definição de classe.
Anotação @Query
Usar consultas nomeadas para declarar consultas para entidades é uma
abordagem válida e funciona bem para um pequeno número de consultas.
Como as consultas em si estão vinculadas ao método Java que as executa, você
pode vinculá-las diretamente usando a @Query anotação Spring Data JPA, em vez
de anotá-las na classe de domínio.
Isso liberará a classe de domínio de informações específicas de persistência e
colocará a consulta na interface do repositório.
Anotação @Modifying
Mas se os métodos não são implementados pelo desenvolvedor, e sim apenas a
assinatura deles, como criar métodos de update ou delete, específicos para uma
dada situação? Bem, para isso, o Spring-Data fornece a anotação @Modifying
 A anotação @Modifying deve ser utilizada em conjunto com a anotação @Query.
Na anotação @Query se adiciona a JPQL em questão, referente a operação de
update ou delete.
E a anotação @Modifying será usada apenas para informar ao Spring-Data que a
@Query não possuí um método de consulta, mas sim, um método de escrita.
Outro ponto importante que deve ser levado em conta é o uso da anotação
@Transactional com o atributo readOnly setado como false.
Isto porque, todas as interfaces que herdam CrudRepository são por padrão do
tipo readOnly = true, ou seja, todos os métodos que você assinar na interface,
serão do tipo leitura e não de escrita.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Então, para evitar uma exceção na transação dos métodos anotados com
@Modifying, é preciso inserir a @Transactional(readOnly = false), para dizer que
esta transação não será para leitura e sim de escrita.
Sobrescrevendo métodos de interface
É possível sobrescrever métodos de interfaces no Java e na parte de persistencia
é muito comum acontecer verificações antes de salvar algum registro, caso seja
necessário criar um método especifico dentro do Repository é possível fazer
usando truques da linguagem Java.
Junit com Spring Data
Junit é um do frameworks mais famosos no mundo Java para a criação de testes
unitários, como nesses momento não temos telas do sistemas para testar a
camada de persistencia do sistema é super útil implementar testes para verificar se
tudo esta funcionando corretamente em nosso sistemas.
O que temos que fazer é quando algum método que temos que testar antes de
tudo o arquivo de configuração do Spring tem que ser lido pra podermos ter todos
os recursos acessiveis.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Essa configuração é feita com anotações e nela passamos o caminho do nosso
arquivo para que seja lido e configurado automaticamente.
Anotação @Autowired
Injeção de dependências (ou Dependency Injection – DI) é um tipo de inversão de
controle (ou Inversion of Control – IoC) que dá nome ao processo de prover
instâncias de classes que um objeto precisa para funcionar.
Marca um construtor, um campo, um método setter ou um método de configuração
para ser autoperfurado pelos recursos de injeção de dependência do Spring.
Depois que a injeção de anotação é ativada, o autowiring pode ser usado em
propriedades, setters e construtores.
Apenas um construtor (no máximo) de qualquer classe de bean pode levar esta
anotação, indicando que o construtor será ativado quando usado como um bean
Spring. Tal construtor não precisa ser público.
Os campos são injetados logo após a construção de um bean, antes que qualquer
método de configuração seja invocado. Esse campo de configuração não precisa
ser público.
Os métodos de configuração podem ter um nome arbitrário e qualquer número de
argumentos; Cada um desses argumentos será autowired com um bean
correspondente no contêiner Spring. Os métodos de definição de propriedade do
bean são efetivamente apenas um caso especial de um método de configuração
geral. Esses métodos de configuração não precisam ser públicos.
No caso de um construtor ou método multi-arg, o parâmetro 'required' é aplicável a
todos os argumentos. Parâmetros individuais podem ser declarados como estilo
Java-8 Optionalou, como no Spring Framework 5.0, também como @Nullable ou
um tipo de parâmetro não-nulo em Kotlin, substituindo a semântica necessária
básica.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
No caso de um tipo Collectionou Mapdependência, o contêiner retira todos os
beans correspondentes ao tipo de valor declarado. Para tais propósitos, as chaves
do mapa devem ser declaradas como tipo String, o qual será resolvido para os
nomes de beans correspondentes. Tal coleta fornecida por contêiner será
ordenada, levando em conta Ordered/ Order valores dos componentes de destino,
caso contrário, seguindo sua ordem de registro no contêiner.
Como alternativa, um único bean de destino correspondente também pode ser
geralmente digitado Collectionou em Mapsi, sendo injetado como tal.
Teste unitário @Test
O conceito de Desenvolvimento Guiado por Testes define que antes de criarmos
um código novo (classe), devemos escrever um teste (classe de test case) para
ele. Essa prática traz vários benefícios às equipes de desenvolvimento e inclusive
estes testes serão usados como métrica em todo o tempo de vida do projeto.
Imagine por exemplo, se um avião só fosse testado após a conclusão de sua
construção, com certeza isso seria um verdadeiro desastre, é nesse ponto que a
engenharia aeronáutica é uma boa referência em processos de construções de
projetos de software, principalmente em sistemas de missão crítica, pois durante a
construção e montagem de um avião todos os seus componentes são testados
isoladamente até a exaustão, e depois cada etapa de integração também é
devidamente testada e homologada.
O teste unitário, de certa forma se baseia nessa ideia, pois é uma modalidade de
testes que se concentra na verificação da menor unidade do projeto de software. É
realizado o teste de uma unidade lógica, com uso de dados suficientes para se
testar apenas à lógica da unidade em questão.
Em sistemas construídos com uso de linguagens orientadas a objetos, essa
unidade pode ser identificada como um método, uma classe ou mesmo um objeto.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Criando o teste de inserir
Anotando nosso método com @Test ele será executado automaticamente e
nossos métodos serão rodados simulando 100% como se fosse nosso sistema
rodando em produção.
Então para cadastrar nosso objetos no banco de dados precisamos instanciar esse
objeto e setar os atributos que serão cadastrados no banco de dados e pra
finalizar apenas chamamos nosso método de salvar.
Criando o teste de consulta
Anotando nosso método com @Test ele será executado automaticamente e
nossos métodos serão rodados simulando 100% como se fosse nosso sistema
rodando em produção.
Então para consultar nosso objetos no banco de dados precisamos apenas chamar
nossa interface de persistencia e invocar o método de consulta que nosso caso é o
findById.
O Spring Data quando efetuamos consulta a um objeto ele é retornado dentro de
um objeto chamado Optional que possui algum métodos que ajudam em
verificações e o mais importante é o método GET que retorna o obejto em si que
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
precisamos da nossa camada de modelo e então para isso nós resgatamos ele da
seguinte forma →usuarioSpringData.get();
Criando o teste de consulta por lista
Anotando nosso método com @Test ele será executado automaticamente e
nossos métodos serão rodados simulando 100% como se fosse nosso sistema
rodando em produção.
Então para consultar todos os dados de nossos objetos no banco de dados
precisamos apenas chamar nossa interface de persistencia e invocar o método de
consulta que nosso caso é o findAll.
O Spring Data quando efetuamos consulta por lista é retornado diretamente a lista
de objetos já pronta para nós então para trabalhar esse lista nós precisamos
percorrer ela e processar da forma que queremos em nosso sistema.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Criando o teste de update
Para efetuarmos o update/atualização de dados em nosso banco de dados nós
precisamos resgatar esse objeto do banco de dados e após isso como ele em
mãos setar os atributos com novos valores e invocar novamente o método de
salvar para gravar as alterações no banco de dados.
Criando o teste de delete
Para efetuarmos o delete/remoção de um registro no banco de dados nós
podemos buscar no banco de dados e passar para nosso método de delete ou
também podemos passar um delete direto para o banco, mas aqui nesse exemplo
estou buscando os dados no banco e passando para nossa camada de
persistencia deletar para ter a certeza que está funcionando a rotina que foi criada.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Consulta assíncrona
As consultas de repositório podem ser executadas de forma assíncrona usando o
recurso de execução de método assíncrono do Spring .
Isso significa que o método retorna imediatamente após a chamada enquanto a
execução real da consulta ocorre em uma tarefa que foi enviada para um Spring
TaskExecutor.
A execução de consulta assíncrona é diferente da execução de consulta reativa e
não deve ser mesclada.
Em poucas palavras isso significa que uma consulta muito demorada fica rodando
por baixo dos panos até ficar concluída e isso é feito com @Async.
Usando Sort
A classificação pode ser feita fornecendo um PageRequestou usando
Sortdiretamente. As propriedades realmente usadas nas Orderinstâncias de
Sortnecessidade correspondem ao seu modelo de domínio, o que significa que
elas precisam ser resolvidas para uma propriedade ou um alias usado na consulta.
O JPQL define isso como uma expressão de caminho de campo de estado.
No entanto, o uso em Sortconjunto @Query permite que você se esgueire em
Order instâncias não verificadas por caminho contendo funções dentro da ORDER
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
BYcláusula. Isso é possível porque o Orderé anexado à string de consulta
fornecida.
Por padrão, o Spring Data JPA rejeita qualquer Order instância que contenha
chamadas de função, mas você pode usar JpaSort.unsafe para adicionar pedidos
potencialmente inseguros.
Então para criarmos nossa consulta com ordenação nós criamos um método que
recebe o objeto Sort e quando formos chamar a rotina nós passar o Sort e a
propriedade do objeto que é para usar na nossa ordenação.
Método criado em nosso repositório.
E na chamada podemos passar um ou vários atributos para ordenação.
Auditoria
O Spring Data fornece suporte sofisticado para controlar de forma transparente
quem criou ou mudou uma entidade e quando a mudança aconteceu. Para se
beneficiar dessa funcionalidade, você precisa equipar suas classes de entidade
com metadados de auditoria que podem ser definidos usando anotações ou
implementando uma interface.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Metadados de auditoria baseados em anotação
Nós fornecemos @CreatedBye @LastModifiedBypara capturar o usuário que criou
ou modificou a entidade, bem como @CreatedDatee @LastModifiedDatepara
capturar quando a mudança aconteceu.
Como você pode ver, as anotações podem ser aplicadas seletivamente,
dependendo de quais informações você deseja capturar.
Caso você não queira usar anotações para definir metadados de auditoria, você
pode permitir que sua classe de domínio implemente a Auditableinterface. Ele
expõe métodos setter para todas as propriedades de auditoria.
Há também uma classe base de conveniência AbstractAuditable, que você pode
estender para evitar a necessidade de implementar manualmente os métodos de
interface.
Isso aumenta o acoplamento de suas classes de domínio ao Spring Data, que
pode ser algo que você deseja evitar. Normalmente, a maneira baseada em
anotação de definir metadados de auditoria é preferida, pois é menos invasiva e
mais flexível.
Caso você use uma @CreatedByou outra @LastModifiedBy, a infraestrutura de
auditoria precisa, de alguma forma, tomar conhecimento do principal atual. Para
isso, fornecemos uma AuditorAware<T> interface SPI que você precisa
implementar para informar a infraestrutura que o usuário ou sistema atual está
interagindo com o aplicativo.
O tipo genérico T define com que tipo as propriedades são anotadas
@CreatedByou @LastModifiedByprecisam ser.
Considerações finais sobre o Spring Data
Vimos a facilidade que um frameworks de persistência trás pra gente, como
operações complexas se tornam muito fáceis com uso de anotações e como o
código fica cada vez mais simples e eficiente estudando e aplicando técnicas
oferecidas pelo frameworks ao nosso projeto.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Spring Web MVC
O Spring Web MVC é o framework web original criado na API Servlet e foi incluído
no Spring Framework desde o início. O nome formal, “Spring Web MVC”, vem do
nome do seu módulo de origem ( spring-webmvc), mas é mais comumente
conhecido como “Spring MVC”.
O Spring MVC, como muitos outros frameworks web, é projetado em torno do
padrão de front controller, onde a central Servlet, the DispatcherServlet, fornece
um algoritmo compartilhado para o processamento de solicitações, enquanto o
trabalho real é executado por componentes delegados configuráveis. Este modelo
é flexível e suporta diversos fluxos de trabalho.
O DispatcherServlet, como qualquer Servlet, precisa ser declarado e mapeado de
acordo com a especificação Servlet usando a configuração Java ou em web.xml.
Por sua vez, o DispatcherServletusa a configuração Spring para descobrir os
componentes delegados necessários para o mapeamento de solicitações, a
resolução da exibição, o tratamento de exceções e muito mais .
Spring RESTful
O REST tornou-se rapidamente o padrão de fato para a criação de serviços da
Web na Web, porque eles são fáceis de construir e fáceis de consumir.
Há uma discussão muito maior sobre como o REST se encaixa no mundo dos
microsserviços, mas - para este tutorial - vamos apenas olhar para a construção de
serviços RESTful.
Por que REST? REST abraça os preceitos da web, incluindo sua arquitetura,
benefícios e tudo mais. Isso não é surpresa, já que seu autor, Roy Fielding, esteve
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
envolvido em provavelmente uma dúzia de especificações que governam como a
web opera.
Quais benefícios? A web e seu protocolo principal, HTTP, fornecem uma pilha de
recursos:
Ações adequadas ( GET, POST, PUT, DELETE, ...)
Cache
Redirecionamento e encaminhamento
Segurança (criptografia e autenticação)
Todos esses são fatores críticos na construção de serviços resilientes. Mas isso
não é tudo. A web é construída a partir de muitas especificações minúsculas, por
isso, tem sido capaz de evoluir facilmente, sem se atolar em "guerras de padrões".
Os desenvolvedores são capazes de utilizar ferramentas de terceiros que
implementam essas diversas especificações e, instantaneamente, têm a tecnologia
de cliente e servidor na ponta dos dedos.
Assim, construindo sobre HTTP, as APIs REST fornecem os meios para construir
APIs flexíveis que podem:
Suportar compatibilidade com versões anteriores
• APIs evolutivas
• Serviços escalonáveis
• Serviços seguráveis
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
• Um espectro de serviços sem estado a stateful
O que é importante perceber é que o REST, por mais onipresente que seja, não é
um padrão, por si só , mas uma abordagem, um estilo, um conjunto de restrições
em sua arquitetura que pode ajudá-lo a construir sistemas em escala da web.
Neste tutorial, usaremos o portfólio do Spring para criar um serviço RESTful,
aproveitando os recursos sem pilha do REST.
Spring Boot
Se você está começando com o Spring Boot, ou “Spring” em geral, comece lendo
esta seção. Ele responde às questões básicas “o quê?”, “Como?” E “por
quê?”. Inclui uma introdução ao Spring Boot, juntamente com instruções de
instalação. Nós, em seguida, orientá-lo através da construção de sua primeira
aplicação Spring Boot, discutindo alguns princípios fundamentais como nós vamos.
O Spring Boot facilita a criação de aplicativos baseados em Spring autônomos e de
produção que você pode executar. Adotamos uma visão opinativa da plataforma
Spring e de bibliotecas de terceiros, para que você possa começar com o mínimo
de barulho. A maioria dos aplicativos Spring Boot precisa de uma configuração de
Spring muito pequena.
Você pode usar o Spring Boot para criar aplicativos Java que podem ser iniciados
usando java -jar ou mais implementações tradicionais de guerra.
Nossos principais objetivos são:
• Forneça uma experiência de introdução radicalmente mais rápida e
amplamente acessível para todo o desenvolvimento do Spring.
• Seja opinativo fora da caixa, mas saia do caminho rapidamente, pois os
requisitos começam a divergir dos padrões.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
• Forneça vários recursos não funcionais que são comuns a grandes classes
de projetos (como servidores incorporados, segurança, métricas,
verificações de integridade e configuração externalizada).
• Absolutamente nenhuma geração de código e nenhum requisito para
configuração XML.
Spring Batch
Muitos aplicativos dentro do domínio corporativo exigem processamento em massa
para realizar negócios operações em ambientes de missão crítica. Essas
operações de negócios incluem:
• Processamento automatizado e complexo de grandes volumes de informação
que é mais eficiente processado sem interação do usuário. Essas operações
geralmente incluem eventos baseados em tempo cálculos, avisos ou
correspondências do final do mês).
• Aplicação periódica de regras de negócios complexas processadas
repetidamente em conjuntos de dados muito grandes (por exemplo, determinação
de benefícios de seguro ou ajustes de taxa).
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
• Integração de informações recebidas de sistemas internos e externos que
normalmente requer formatação, validação e processamento de forma transacional
para o sistema de registro. O processamento em lote é usado para processar
bilhões de transações todos os dias para empresas.
O Spring Batch é uma estrutura em lote leve e abrangente projetada para permitir
o desenvolvimento de aplicações em lote robustas, vitais para as operações diárias
dos sistemas corporativos.
Constrói sobre as características do Spring Framework que as pessoas esperam
(produtividade, Abordagem de desenvolvimento baseada em POJO e facilidade
geral de uso), facilitando ao acesso e alavancar serviços empresariais mais
avançados quando necessário.
Spring Batch não é um estrutura de agendamento. Existem muitos planejadores
corporativos bons (como Quartz, Tivoli, ControlM, etc.) disponível nos espaços
comerciais e de código aberto.
Pretende-se trabalhar em conjunção com um agendador, não substitua um
agendador.
O Spring Batch fornece funções reutilizáveis que são essenciais no processamento
de grandes volumes de registros. incluindo registro / rastreamento, gerenciamento
de transações, estatísticas de processamento de tarefas, reinicialização de tarefas,
ignorar e gestão de recursos.
Ele também fornece serviços técnicos e recursos mais avançados que permitem
trabalhos em lote de volume extremamente alto e alto desempenho por meio de
otimização e particionamento técnicas.
O Spring Batch pode ser usado em ambos os casos de uso simples (como ler um
arquivo em um banco de dados ou executando um procedimento armazenado),
bem como casos de uso complexos e de alto volume (como volumes de dados
entre bancos de dados, transformando-os e assim por diante). Trabalhos em lote
de alto volume aproveite a estrutura de maneira altamente escalonável para
processar volumes significativos de informações.
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
CLIQUE AQUI – E conheça o curso Formação em Java Web Full-Stack
Spring Batch Architecture
O Spring Batch é projetado com extensibilidade e um grupo diversificado de
usuários finais em mente.
A figura abaixo mostra a arquitetura em camadas que suporta a extensibilidade e a
facilidade de uso para o usuário final desenvolvedores.
Essa arquitetura em camadas destaca três principais componentes de alto nível:
Application, Core e a infraestrutura. O aplicativo contém todos os trabalhos em
lote e código personalizado escritos por desenvolvedores usando Lote em Spring.
O Núcleo de Lote contém as classes principais de tempo de execução necessárias
para iniciar e controlar trabalho em lote. Inclui implementações para JobLauncher,
Job e Step. Aplicativo e Núcleo são
construído em cima de uma infra-estrutura comum. Esta infra-estrutura contém
leitores e escritores comuns e serviços (como o RetryTemplate), que são usados
tanto por desenvolvedores de aplicativos (leitores e escritores, como ItemReader e
ItemWriter) e o próprio framework principal (tente novamente, que é própria
biblioteca).